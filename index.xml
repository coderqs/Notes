<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>清松的笔记本</title><link>https://coderqs.github.io/</link><description>Recent content on 清松的笔记本</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://coderqs.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E6%8A%80%E5%B7%A7/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E7%9A%84%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E6%8A%80%E5%B7%A7/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E7%9A%84%E4%BD%BF%E7%94%A8/</guid><description>======= 常用的指令 =======
1. &amp;quot; (双引号) # 把搜索词放在双引号（英文半角）中，代表完全匹配搜索，也就是说搜索结果返回的页面包含双引号中出现的所有的词，连顺序也必须完全匹配。Google和百度都支持这个指令。 例如：
&amp;ldquo;seo方法图片&amp;rdquo;
2. - (减号) # 代表搜索不包含减号后面的词的页面。使用这个指令时减号前面必须是空格，减号后面没有空格，紧跟着需要排除的词。Google和百度都支持这个指令。 例如：
搜索 -引擎
返回的结果中包含搜索但不包含引擎
3. * (星号) # 是常用的通配符，也可以用在搜索中。百度不支持 * 号搜索指令。 例如：
搜索*擎
其中的*号代表任何文字。返回的结果就不仅包含“搜索引擎”，还包含了“搜索收擎”，“搜索巨擎”等内容。
4. ~(波浪线) # 代表搜索包含这个词以及合适的近义词的页面。貌似百度不支持该搜索指令 例如：
~elderly
所得到的页面就会不仅是包括“elderly”这个词，还会有包括“senior”、“older”、“aged”等等词的页面。
5. inurl # inurl: 指令用于搜索查询词出现在url 中的页面，inurl 指令支持中文和英文。百度和Google都支持这个指令。 例如：
inurl:搜索引擎优化
返回的结果都是网址url 中包含“搜索引擎优化”的页面。由于关键词出现在url 中对排名有一定影响，使用inurl:搜索可以更准确地找到竞争对手。
6. inanchor # inanchor:指令返回的结果是导入链接锚文字中包含搜索词的页面。百度不支持inanchor。 例如：
inanchor:点击这里</description></item><item><title/><link>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E6%9C%8D%E5%8A%A1/dokuwiki/%E4%B8%AA%E6%80%A7%E5%8C%96%E7%9A%84%E8%AE%BE%E7%BD%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E6%9C%8D%E5%8A%A1/dokuwiki/%E4%B8%AA%E6%80%A7%E5%8C%96%E7%9A%84%E8%AE%BE%E7%BD%AE/</guid><description>dokuwiki 的个性化设置 # 添加侧边栏 # 有的主题是默认带有侧边栏的，而我使用的 Bootstrap3 主题带有右侧边栏，其显示当前文章的内容的索引，想要显示整个 wiki 的索引还需要使用插件 start#IndexMenu。 插件的添加与使用请参考其文档，这里介绍如何使其成为独立的侧边栏。
添加一个名为 sidebar 的页面。注：这是默认的名字，如果修改了配置中的 基本配置-&amp;gt;sidebar 的配置，需要与其修改后的名字一致 编辑该页面，添加如下语句，保存即可。 {{indexmenu&amp;gt;..#1|js navbar nocookie}} 在侧边栏中隐藏 sidebar 和 start 页面 # 上面方法添加的侧边栏中会把 sidebar 和 start 页面显示出来，如果不想显示，则将 sidebar 页面中的语句修改成下面的即可
{{indexmenu&amp;gt;..#1 |js#bj-tango.png navbar max#3#2 skipfile+/(^|:)(start|sidebar)$/ skipns=/^users$/}} 注：上面的语句还隐藏了 users 名字空间，如果想显示，则将 skipns=/^users$/ 删掉即可。
修改上传附件大小为2M限制 # 修改 /etc/php.ini 中的两个参数
upload_max_filesize = 10M post_max_size = 10M 注: Windows环境中尽管会提示上传文件过大，但好像实际并不会限制上传。</description></item><item><title/><link>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E6%9C%8D%E5%8A%A1/dokuwiki/%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E6%9C%8D%E5%8A%A1/dokuwiki/%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/</guid><description>系统要求 # 1. 支持 PHP 的 Web 服务器
2. PHP 至少是 5.6 版本以上的，最好是最新的版本
详细要求可参阅 官网的相关说明
下载 # 在 官网下载最新稳定版的压缩包
Web 服务的配置 # 在 官网中的 Webserver Specifics有提供了几款常见的 web 服务器的配置，在这里只展示了我用的 nginx 的配置
nginx # 添加配置文件 /etc/nginx/conf.d/dokuwiki.conf
server { listen 443 ssl; server_name wiki.mydomain.com; root /var/www/html/dokuwiki; index index.html index.php doku.php; access_log /var/log/nginx/dokuwiki.access.log; error_log /var/log/nginx/dokuwiki.error.log; ssl on; ssl_certificate /etc/letsencrypt/live/wiki.mydomain.com/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/wiki.</description></item><item><title/><link>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E6%9C%8D%E5%8A%A1/dokuwiki/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E6%9C%8D%E5%8A%A1/dokuwiki/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</guid><description>禁止您无权访问此服务器上的/dokuwiki # 权限问题，检查以下两点
注意下dokuwiki下文件的权限（nginx的执行用户是nginx） dokuwiki.conf的中指定的路径是否正确 because search permissions are missing on a component of the path # 关闭 SELinux 即可，关闭命令
setenforce 0 访问网页返回 502 bad gateway # nginx 找不到 php 了，检查下 nginx 对应的服务的配置中的 fastcgi_pass unix 项和 php 的 www.conf 配置文件中的 listen 的值是否一致
中文文件名乱码 # 在网页创建的中文名字空间和页面后，在服务器上全都显示的都是乱码 在文件 conf/local.php 最后添加
$conf['fnencode'] = 'utf-8'; 修改 inc/pageutils.php
function utf8_encodeFN($file,$safe=true){ global $conf; if($conf['fnencode'] == 'utf-8') return $file; if($safe &amp;amp;&amp;amp; preg_match('#^[a-zA-Z0-9/_\-\.</description></item><item><title/><link>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E6%9C%8D%E5%8A%A1/dokuwiki/%E6%8F%92%E4%BB%B6%E4%B8%8E%E4%B8%BB%E9%A2%98/indexmenu/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E6%9C%8D%E5%8A%A1/dokuwiki/%E6%8F%92%E4%BB%B6%E4%B8%8E%E4%B8%BB%E9%A2%98/indexmenu/</guid><description>indexmenu # indexmenu 可以插入完全可自定义的索引或从指定名称空间开始的页面列表。
基本语法 # {{indexmenu&amp;gt;ns[#n] [ns1[#n] ns2[#n] …] | [js[#theme]] [tsort] … }} [] 内的是可选项
常用的几种语句 # 从根名称空间显示 # 全部展开
{{indexmenu&amp;gt;:}} 从当前名称空间 # 仅显示当前级别，不展开任何节点
{{indexmenu&amp;gt;.#1}} 展开当前页面的父名称空间 # 显示父名称空间（“上行链路”）和当前级别，不展开任何节点
{{indexmenu&amp;gt;..:#1}} 展开包含指定的名称空间 # 以展开包含 wiki 的名称空间为例，语法如下：
{{indexmenu&amp;gt;:wiki#1|js}} 不显示指定的名字空间 # 以不显示 users 名字空间为例，语法如下：
{{indexmenu&amp;gt;.:#1|js skipns=/^users$/}} 不显示指定页面 # 以不显示 start 和 sidebar 页面为例，语法如下：</description></item><item><title/><link>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E6%9C%8D%E5%8A%A1/dokuwiki/%E6%8F%92%E4%BB%B6%E4%B8%8E%E4%B8%BB%E9%A2%98/start/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E6%9C%8D%E5%8A%A1/dokuwiki/%E6%8F%92%E4%BB%B6%E4%B8%8E%E4%B8%BB%E9%A2%98/start/</guid><description>当前使用的主题 # Bootstrap3 # 文档
当前使用的插件 # Add New Page # 文档
创建新的 wiki 页面
move # 文档
移动页面和名字空间
IndexMenu # 文档
显示全局的索引。
nspages # 文档
显示页面列表。
smtp # 文档
使用自定义的邮箱发送邮件。
fastwiki # 文档
提供快速编辑功能，能在页面中只修改一部分，不用渲染整个页面
mathjax # 文档
支持 mathjax 数学公式的语法，目前不怎么用数学公式，使用率低暂时先关闭了。
dw2pdf # 文档
提供 pdf 下载的功能，在个人知识库中没有使用这个功能。
vshare # 文档</description></item><item><title/><link>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E6%9C%8D%E5%8A%A1/mediasoup/mediasoup%E7%9A%84%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E6%9C%8D%E5%8A%A1/mediasoup/mediasoup%E7%9A%84%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/</guid><description>Mediasoup 的安装与部署 # 环境要求 # 官方要求：
cmake &amp;gt;= 3.5 gcc 和 g++ &amp;gt;= 4.9 或 clang（具有C++ 11支持） node.js &amp;gt;= 10.0, npm &amp;gt;= 6.3 使用 cmake --version 检查是否需要[安装或升级](/工具/编程工具/编译工具/cmake/介绍与安装#CMake 的安装) CMake，gcc --version 检查是否需要[升级 GCC](/操作系统/linux/升级gcc#编译 GCC), nodejs -v 检查是否需要[[|安装或升级]] Nodejs
除了上述的环境还需要 编译安装部署#安装 python
安装 # 下载 # 需要下载 mediasoup v3 mediasoup v3 demo github，在 github 上下载就可以
安装 mediasoup-demo # cd mediasoup-demo/server npm install cd ../app npm install 注意： 如果 npm 速度过慢或者超时，可以将源修改为淘宝的源或者[[|使用 cnpm]]</description></item><item><title/><link>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E6%9C%8D%E5%8A%A1/nginx/%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E6%9C%8D%E5%8A%A1/nginx/%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/</guid><description>======= Nginx 安装与部署 =======
命令安装 # 先安装
sudo yum install -y yum-utils 设置 yum 存储库，创建/etc/yum.repos.d/nginx.repo文件输入以下内容：
[nginx-stable] name=nginx stable repo baseurl=http://nginx.org/packages/centos/\$releasever/\$basearch/ gpgcheck=1 enabled=1 gpgkey=https://nginx.org/keys/nginx_signing.key module_hotfixes=true [nginx-mainline] name=nginx mainline repo baseurl=http://nginx.org/packages/mainline/centos/\$releasever/\$basearch/ gpgcheck=1 enabled=0 gpgkey=https://nginx.org/keys/nginx_signing.key module_hotfixes=true 默认情况下，使用的是稳定版的 nginx 软件包存储库，如需要使用主线版本，则执行下面命令：
sudo yum-config-manager --enable nginx-mainline 然后再执行安装命令
sudo yum -y install nginx 综合以上命令
sudo yum install -y yum-utils cat&amp;gt;&amp;#34;/etc/yum.repos.d/nginx.repo&amp;#34;&amp;lt;&amp;lt;EOF [nginx-stable] name=nginx stable repo baseurl=http://nginx.org/packages/centos/\$releasever/\$basearch/ gpgcheck=1 enabled=1 gpgkey=https://nginx.org/keys/nginx_signing.key module_hotfixes=true [nginx-mainline] name=nginx mainline repo baseurl=http://nginx.</description></item><item><title/><link>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E6%9C%8D%E5%8A%A1/nginx/%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E6%9C%8D%E5%8A%A1/nginx/%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/</guid><description>Nginx 的常用配置 # Post 返回静态内容 # 因为 Nginx 有着无法根据 POST 请求提供静态内容的限制，所以可以利用这个限制将 405 错误信息替换成静态内容来达到目的。主要配置
error_page 405 =200 $uri 参考资料 # POST 请求出现 405（不允许）
不允许 POST 请求 - 405 Not Allowed - nginx，即使包含标头
Serving Static Content Via POST From Nginx
接收 Post 请求参数 # 在文件 nginx.conf 中 http 的配置里添加下面的内容
http{ ... log_format post_tracking '$remote_addr - $remote_user [$time_local] &amp;quot;$request&amp;quot; ' '$status $body_bytes_sent &amp;quot;$http_referer&amp;quot; ' '&amp;quot;$http_user_agent&amp;quot; &amp;quot;$http_x_forwarded_for&amp;quot; &amp;quot;$request_body&amp;quot; '; .</description></item><item><title/><link>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E6%9C%8D%E5%8A%A1/prometheus/%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E6%9C%8D%E5%8A%A1/prometheus/%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%BD%BF%E7%94%A8/</guid><description>Prometheus 的部署与使用 #</description></item><item><title/><link>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/ci_cd/jenkins/jenkins%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/ci_cd/jenkins/jenkins%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/</guid><description>Jenkins 的安装与部署 # 准备 # 硬件要求 # 最低硬件要求
256 MB 内存; 1 GB 的驱动器空间（尽管如果将 Jenkins 作为 Docker 容器运行，建议至少使用 10 GB）; 小团队推荐的硬件配置：
4 GB+ 的内存; 50 GB+ 的驱动器空间; 更多要求请参考官方的 硬件推荐
软件要求 # Java # 32 位和 64 位版本均支持 Java 8 运行时环境 支持 Java 11 运行时环境 Java 11 Docker 安装说明包含在“在 Docker 中下载和运行 Jenkins”中 有关其他升级说明，请参阅Java 8 到 Java 11 升级指南 不支持 Java 7 及之前版本 不支持 Java 9 和 10 不支持 Java 12、13、14、15 和 16 这些要求适用于 Jenkins 系统的所有组件，包括 Jenkins 控制器、所有类型的代理、CLI 客户端和其他组件。</description></item><item><title/><link>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/ci_cd/jenkins/jenkins%E9%85%8D%E7%BD%AEsvn%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E7%8E%AF%E5%A2%83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/ci_cd/jenkins/jenkins%E9%85%8D%E7%BD%AEsvn%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E7%8E%AF%E5%A2%83/</guid><description>Jenkins 配置 SVN 持续集成环境 # 准备 # 安装 Jenkins 插件 Subversion
配置 # 将 SVN 的用户名和密码添加到 凭证中; 创建一个新的任务; 勾选 General 中的 限制项目的运行节点 并指定节点(无需要可以跳过这步); 源码管理 中勾选 Subversion，在 Repository URL 中添加仓库的地址，Credentials 选择第 1 步中配置的凭证;
勾选 构建触发器 中的 Build periodically(控制任务的构建周期) 和 Poll SCM(检查 SVN 是否有新的提交的周期)，下图示例是每 30 分钟构建一次任务，5 分钟检查一次 SVN 是否更新;
勾选 构建环境 中的 Delete workspace before build starts(无需要可以跳过这步); 构建 -&amp;gt; 增加构建步骤 中选择准备使用的方式(一般 Linux 环境使用 Execute shell，Windows 使用 Execute Windows batch command); 扩展 # windows 构建方法 # 在 Windows 下 Jenkins 自带的构建步骤是使用 Windows 批处理脚本，想要编译 VS 的工程会比较麻烦，在这里推荐使用插件 MSBuild。</description></item><item><title/><link>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/ide/visual_studio/cpp%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE%E4%BB%8B%E7%BB%8D/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/ide/visual_studio/cpp%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE%E4%BB%8B%E7%BB%8D/</guid><description>Visual Studio 的 C++ 项目中的一些配置的介绍 # VC++包含目录和 C++ 附加包含目录的区别 # c/c++ 附加包含目录，代表的是c/c++文件编译时所需要的头文件，而资源编译时也是需要附加包含库目录的，而 vc++ 的包含目录，代表的是全局项目的包含目录。配置过VC++里面的库，C/C++里面的就可以不用配置。
参考资料 # VC包含目录和c/c 附加包含目录的区别
默认的属性文件 # vs2017 # Microsoft.Cpp.x64.user 系统默认的属性表，全路径为 C:\Users\horswing\AppData\Local\Microsoft\MSBuild\v4.0\Microsoft.Cpp.x64.user.props 项目创建后，默认有这个属性表。双击可以修改（效果与 solution explorer 项目名上右键 -&amp;gt; property 一致），右键选则 remove 和移除。 Application 表示这个项目生成的是一个“应用程序”（不是DLL或LIB）。在 Property Manger 里，这项是不能改的，所以你发现双击后，出现的页面是灰色的，右键也只有 property 选项。 在哪里改呢？
在 solution explorer 里的 项目属性 -&amp;gt; gerneral -&amp;gt; Project Defaults -&amp;gt; Configuration Type. Unicode Support 和 Core Windows Libraries 和 Application 项一样，这两项也是“只能看不能改的”，要改分别在 项目属性 -&amp;gt; gerneral -&amp;gt; Project Defaults 里的 Character Set 和 Use of MFC 修改。 vs2019 # vs2019 相较于 vs2017 少了 Microsoft.</description></item><item><title/><link>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/ide/visual_studio/visual_studio%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AE%9E%E7%94%A8%E5%8A%9F%E8%83%BD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/ide/visual_studio/visual_studio%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AE%9E%E7%94%A8%E5%8A%9F%E8%83%BD/</guid><description>Visual Studio 的一些实用功能 # 代码编辑 # 代码格式化 # Visual Studio 2017 15.7 Preview 1 为 C++ 开发人员提供了内置的 ClangFormat 支持。内置 LLVM、Google、Chromium、Mozilla 或 WebKit 等格式约定。
=== 使用方式 === 快捷键：Ctrl+k Ctrl+d
菜单选项：编辑 -&amp;gt; 格式文档
选择格式 # 工具 -&amp;gt; 选项 -&amp;gt; 文本编辑器 -&amp;gt; C/C++ -&amp;gt; 代码样式 -&amp;gt; 格式设置 -&amp;gt; 默认格式设置样式
参考资料 # Visual Studio 2017 中的 ClangFormat 支持
Visual Studio和VS Code使用clang-format自定义C++代码默认格式化样式</description></item><item><title/><link>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/ide/vscode/%E6%8F%92%E4%BB%B6remote_ssh%E7%9A%84%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/ide/vscode/%E6%8F%92%E4%BB%B6remote_ssh%E7%9A%84%E4%BD%BF%E7%94%A8/</guid><description>插件 Remote-SSH 的使用 # 安装 # 在 vscode 的扩展里搜索 Remote-SSH
点击安装，等待安装完成即可，安装完成后会在左侧的侧边栏多出一个图标。
配置 # 按顺序点击图中 1、2 的图标; 在图中 3 的位置输出要远程连接的机器的用户名和地址，例如：ssh root@192.168.13.97; 输入完成后回车，点击 C:\User\xxx\.ssh\config 就可以看到连接已添加进来了，如果没有点击图中 4 的位置刷新;
在已添加的连接上右键，选择 Connect to Host in New Windows;
选择目标机器的系统类型（当无法识别目标机器的系统时会弹出该选项）;
选择 Connect; 输入密码;
输完密码后右下角有提示在下载安装 VS Code Server，等待其完成即可;
左下角这里类似这样的显示就是连接完成了;
参考资料 # 使用 SSH 进行远程开发
玩转VSCode插件之Remote-SSH
VSCode:Remote-SSH配置实录</description></item><item><title/><link>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/ide/vscode/%E8%AE%BE%E7%BD%AE%E7%94%A8%E6%88%B7%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/ide/vscode/%E8%AE%BE%E7%BD%AE%E7%94%A8%E6%88%B7%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/</guid><description>设置用户代码片段 # 设置方式 # 以 Markdown 为例
文件 &amp;gt; 首选项 &amp;gt; 用户代码片段 输入 markdown，编辑 markdown.json:
{ // Place your snippets for markdown here. Each snippet is defined under a snippet name and has a prefix, body and // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are: // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders.</description></item><item><title/><link>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E5%88%9B%E5%BB%BA%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E5%88%9B%E5%BB%BA%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</guid><description>Git 创建远程仓库 # 本地远程仓库 # 创建目录 # 在本地要当做远程仓库的路径创建一个空目录（与你要本地仓库同名）并创建裸仓库
mkdir ~/Temp/git_server/Test/ git init--bare 关联仓库 # 本地仓库关联远程仓库
git remote add origin ~/Temp/git_server/Test/ 如果远程地址设置错了，可以使用以下命令重置
git remote set-url origin ~/Temp/git_server/NewTest/ 提交 # 提交到远程仓库
git push -u origin master #!/bin/sh # # An example hook script to prepare a packed repository for use over # dumb transports. # # To enable this hook, rename this file to "post-update". #exec git update-server-info # 添加以下三行即可 unset GIT_DIR cd .</description></item><item><title/><link>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid><description>Git 的常用命令 # 基础命令 # 本地 # 创建存储库 # git init repositories_name 状态查看 # git status 文件操作 # # 添加文件 git add filename # 删除文件 git rm filename # 移动或重命名 git mv filename_src filename_dst 提交文件 # git commit -m &amp;#34;提交内容的描述&amp;#34; 比较差异 # git diff filename 查看提交记录 # git log # 简版记录 git log --pretty=oneline 版本回退 # # 回退到上个版本 git reset --hard HEAD^ # 回退到上上个版本 git reset --hard HEAD^^ # 回退到上100个版本 git reset --hard HEAD~100 # 回退到指定版本 git reset --hard commit_id 查看执行命令的记录 # git reflog</description></item><item><title/><link>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85/</guid><description>git 编译安装 # 准备 # 安装依赖 # yum install -y curl-devel expat-devel gettext-devel openssl-devel zlib-devel yum install -y gcc perl-ExtUtils-MakeMaker 下载源码 # git clone https://github.com/git/git.git 注：如果没有给 git 配置代理的话，建议直接下载压缩包会更快些。
编译 # 编译命令 # make prefix=/usr/local/git all make prefix=/usr/local/git install 这里提醒下，如果 git 的源码是从 windows 下拷过来的要注意下文件的可执行权限
创建软连接 # ln -s /usr/local/git/bin/git /usr/bin/git</description></item><item><title/><link>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E8%A1%8D%E7%94%9F%E5%93%81/gitea/%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E8%A1%8D%E7%94%9F%E5%93%81/gitea/%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/</guid><description>Gitea 安装与部署 # 准备 # 下载文件 # 从官网的 下载页面中选择与目标平台匹配的文件，复制 URL 并替换以下命令中的 URL：
wget -O gitea https://dl.gitea.io/gitea/1.14.5/gitea-1.14.5-linux-amd64 shell chmod +x gitea 环境准备 # 确保已安装 Git # git --version 创建运行 Gitea 的用户 # adduser \ git \ --system \ --shell /bin/bash \ --home /home/git 创建所需的目录结构 # mkdir -p /var/lib/gitea/{custom,data,log} chown -R git:git /var/lib/gitea/ chmod -R 750 /var/lib/gitea/ mkdir /etc/gitea chown root:git /etc/gitea chmod 770 /etc/gitea 注意： /etc/gitea是具有用户写权限的临时设置，git以便Web安装程序可以写配置文件。安装完成后，建议使用以下命令将权限设置为只读：</description></item><item><title/><link>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E8%A1%8D%E7%94%9F%E5%93%81/github/%E6%96%B0%E7%94%A8%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E8%A1%8D%E7%94%9F%E5%93%81/github/%E6%96%B0%E7%94%A8%E6%B3%95/</guid><description>Github 的各种新用法 # 作为图床 # 本 Wiki 就是使用的 github 作为图床。
操作步骤 # 在 github 创建一个仓库，一定要创建公开的仓库，如果是私有的会访问不了。 克隆该仓库到本地，添加一张图片，提交后推送到 github。 在仓库中找到刚刚推送的图片进入预览。 点击下载，会跳转到一个页面，这个页面就是这张图片的外链地址，这个地址就可以在其他地方访问了。 还有一种方法，在预览页面的地址后面加上 ?raw=true 后缀</description></item><item><title/><link>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86/</guid><description>在 &amp;ldquo;科学上网&amp;rdquo; 后使用 git 克隆 github 上的项目速度还是很慢。后来发现 git clone 时并没有走 &amp;ldquo;科学上网&amp;rdquo; 的代理，需要在 git 中设置一下代理才会使用。
设置方法 # 查看 &amp;ldquo;科学上网&amp;rdquo; 开放的端口号与协议是什么，我的端口是 1080，协议是 socks。 打开 git bash 只代理 github git config --global http.https://github.com.proxy socks://127.0.0.1:1080 git config --global https.https://github.com.proxy socks://127.0.0.1:1080 全局代理 git config --global http.proxy socks://127.0.0.1:1080 git config --global https.proxy socks://127.0.0.1:1080 注：
如果 &amp;ldquo;科学上网&amp;rdquo; 使用的协议是 https，则需要将命令中参数 socks://127.0.0.1:1080 替换成 https://127.0.0.1:1080 socks5 与上同理 取消代理 # 取消 github 的代理 git config --global --unset http.</description></item><item><title/><link>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/svn/%E5%BF%BD%E7%95%A5%E6%8C%87%E5%AE%9A%E7%9A%84%E6%96%87%E4%BB%B6%E6%88%96%E7%9B%AE%E5%BD%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/svn/%E5%BF%BD%E7%95%A5%E6%8C%87%E5%AE%9A%E7%9A%84%E6%96%87%E4%BB%B6%E6%88%96%E7%9B%AE%E5%BD%95/</guid><description>SVN 忽略指定的文件或目录 # 和 Git 中的 .gitignore 的功能基本一致。
设置方法 # 在项目下创建一个名为 .svnignore 的文件（svn 对这个没有要求，文件名可任意起，但是为了看起来规范所以叫这个）; 在文件 .svnignore 中添加要忽略的文件或目录，语法与 .gitignore 基本一致，目前发现有以下不同点; svn忽略的文件夹名称后面可以不用斜杠. svn忽略的文件列表，换行符不能是Windows的换行符(\r\n)，必须是 Unix 换行符(\n)，可以使用编辑软件替换掉(例如：Notepad++). 在 svn 跟踪的项目目录下点击右键 -&amp;gt; TortoiseSVN -&amp;gt; Properties 会弹出窗口;
点击窗口右下角的 New... 选择 Other，在弹出的窗口中 Property name 选择 svn:global-ignores;
点击 Load... 选择刚刚准备好的 .svnignore 文件，点击 OK 即可。（不要选择 Apply property recursively 这一项）;
参考资料 # 【全网独家】SVN实现和Git .gitignore一样的全局忽略文件和文件夹</description></item><item><title/><link>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/cmake/%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/cmake/%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85/</guid><description>CMake 介绍与安装 # CMake 介绍 # CMake是一个跨平台的开源的元构建系统，可以构建，测试和打包软件。它可以用于支持多个本机构建环境，包括 make，Apple 的 xcode 和 Microsoft Visual Studio。
CMake 的安装 # Windows # 在官网 下载安装包安装即可。
Centos # 安装 # yum install -y cmake 安装完成后执行下面命令，检查是否成功。
cmake -version 升级 # 有时候命令安装的版本不够，需要更高的版本，这时就需要手动进行升级。
卸载旧的 cmake yum remove -y cmake 在官网的下载页面找到需要的 cmake 版本，下载后并解压。我的命令如下: wget https://github.com/Kitware/CMake/releases/download/v3.20.0-rc2/cmake-3.20.0-rc2-linux-x86_64.tar.gz tar -zxvf cmake-3.20.0-rc2-linux-x86_64.tar.gz 将其复制到你要安装的目录。我安装的目录是 /usr/local/: cp cmake-3.20.0-rc2-linux-x86_64/* /usr/local/ 在 &amp;lsquo;&amp;rsquo;/etc/profile &amp;rsquo;&amp;rsquo; 的最后一行添加你安装的目录，语法为 export PATH=$PATH:你安装的目录/bin。我安装的 /usr/local/ 目录是系统默认包含的，所以可以省略这步。 检查是否安装成功。 可能遇见的问题 # CMake Error: Error executing cmake::LoadCache().</description></item><item><title/><link>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/cmake/%E7%94%9F%E6%88%90xcode%E5%B7%A5%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/cmake/%E7%94%9F%E6%88%90xcode%E5%B7%A5%E7%A8%8B/</guid><description>生成 XCode 工程 # 方法 # cmake 的构建命令增加参数 `-G &amp;ldquo;Xcode&amp;rdquo;`，例如
cmake -G Xcode .. 遇到的问题 # 报错找不到编译器 # 错误信息 # -- The C compiler identification is unknown -- The CXX compiler identification is unknown CMake Error at CMakeLists.txt:2 (project): No CMAKE_C_COMPILER could be found. CMake Error at CMakeLists.txt:2 (project): No CMAKE_CXX_COMPILER could be found. 解决方法 # 执行命令下面的命令后再重试即可</description></item><item><title/><link>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/adb%E7%9A%84%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/adb%E7%9A%84%E4%BD%BF%E7%94%A8/</guid><description>adb 的使用 # 简介 # Android 调试桥 (adb) 是一种功能多样的命令行工具，可让您与设备进行通信。adb 命令可用于执行各种设备操作（例如安装和调试应用），并提供对 Unix shell（可用来在设备上运行各种命令）的访问权限。它是一种客户端-服务器程序，包括以下三个组件：
客户端：用于发送命令。客户端在开发计算机上运行。您可以通过发出 adb 命令从命令行终端调用客户端。 守护程序(adbd)：用于在设备上运行命令。守护程序在每个设备上作为后台进程运行。 服务器：用于管理客户端与守护程序之间的通信。服务器在开发机器上作为后台进程运行。 adb 包含在 Android SDK 平台工具软件包中。您可以使用 SDK 管理器下载此软件包，该管理器会将其安装在 android_sdk/platform-tools/ 下。或者，如果您需要独立的 Android SDK 平台工具软件包，也可以点 击此处进行下载。
如需了解如何连接设备以使用 ADB，包括如何使用 Connection Assistant 对常见问题进行排查，请参阅 在硬件设备上运行应用。
使用 # 常用命令 # adb connect 10.160.93.94 // 连接 adb disconnect // 断开连接 adb devices // 查看设备列表 adb shell 文件操作 # 从设备获取文件 # adb pull /path_in_devices/src_file /local_dst_path 发送文件到设备 # adb push /local_src_path/src_file /path_in_devices/dst_path/ 安装应用 # 应用程序安装-将一个包推送到设备上并安装它 # adb install test.</description></item><item><title/><link>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E6%A3%80%E6%B5%8B/clang-tidy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E6%A3%80%E6%B5%8B/clang-tidy/</guid><description>Clang-Tidy # 简介 # clang-tidy 是一个基于 clang 的 C++ “linter” 工具。其目的是提供一个可扩展的框架，用于诊断和修复典型的编程错误，例如样式违规、接口滥用或可以通过静态分析推断出的错误。clang-tidy 是模块化的，并提供了一个方便的界面来编写新的检查。
安装 # Ubuntu # sudo apt-get install clang-tidy-5.0 Centos # sudo yum install -y centos-release-scl sudo yum install -y llvm-toolset-7 sudo yum install -y llvm-toolset-7-clang-analyzer llvm-toolset-7-clang-tools-extra 启动 # scl enable llvm-toolset-7 &amp;#39;clang -v&amp;#39; scl enable llvm-toolset-7 &amp;#39;lldb -v&amp;#39; scl enable llvm-toolset-7 bash 使用 # clang-tidy -list-checks -checks=&amp;#39;google&amp;#39; test.cpp -- -checks='google': 表示检测是否违反google code style; test.</description></item><item><title/><link>https://coderqs.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/centos7%E6%8C%82%E8%BD%BDwindows%E7%9A%84%E5%85%B1%E4%BA%AB%E7%9B%AE%E5%BD%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/centos7%E6%8C%82%E8%BD%BDwindows%E7%9A%84%E5%85%B1%E4%BA%AB%E7%9B%AE%E5%BD%95/</guid><description>Centos7 挂载 windows 的共享目录 # 步骤 # 1. 在windows上创建一个共享目录 # 设置共享 # 右键需要共享的文件夹，点击“共享”，点击“共享此文件夹”，此时可以设置权限。默认权限是“读取”。
更改权限 # 接着上述步骤，点击“权限”按钮，打开权限对话框，若需要写权限（修改权限），选中Everyone用户组，选中“修改”复选框或者“完全控制”复选框。点击“应用”“确定”。
进入“安全”选项卡，选中Everyone用户组，选中“完全控制”，“应用”“确定”。 更改权限的两步必须同时设置才能生效。
2. 在Centos7上挂载共享目录** 执行下面命令 # mount -t cifs -o username=share,password=share //192.168.31.189/share /share 其中:
username,password 是 windows 登录用户名密码 //192.168.31.189/share 就是windows要的共享文件夹 /share 是希望 Centos7 将共享文件夹要挂载到的地方，可任意定位置 3. 开机启动就挂载文件夹 # 在 /etc/fstab 文件中添加下列代码即可
//192.168.31.189/share /share cifs username=share,password=share 0 0 遇到的问题 # mount -t cifs -o username=share,password=share //192.168.31.189/share /share mount: //192.</description></item><item><title/><link>https://coderqs.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/firewalld%E7%9A%84%E8%A7%84%E5%88%99%E9%85%8D%E7%BD%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/firewalld%E7%9A%84%E8%A7%84%E5%88%99%E9%85%8D%E7%BD%AE/</guid><description>firewalld的规则配置 # 基本功能 # 查看防火墙 # systemctl status firewalld 开启防火墙 # systemctl start firewalld.service 重启防火墙 # firewall-cmd --reload 端口管理 # 查看已开放的端口 # firewall-cmd --zone=public --list-ports 添加端口到白名单 # firewall-cmd --permanent --zone=public --add-port=8484/tcp --zone 作用域 --add-port=8484/tcp 添加端口，格式为：端口/通讯协议 --permanent 永久生效，没有此参数重启后失效 从白名单移除端口 # firewall-cmd --zone=public --remove-port=8484/tcp 服务管理 # 服务只是带有相关名称和描述的端口的简单集合。使用服务比端口更易于管理。
获得可用服务的列表 # firewall-cmd --get-services 查看当前已添加的服务 # firewall-cmd --zone=public --list-services 添加服务 # firewall-cmd --permanent --zone=public --add-service=ssh 自定义服务 # 服务的定义文件通常存放在下面的两个路径中：</description></item><item><title/><link>https://coderqs.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/mailx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/mailx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</guid><description>Mailx 安装与使用 # Mailx 安装 # 安装 # 执行命令
sudo yum install -y mailx 配置 # 在配置文件 /etc/mail.rc 后面追加
set from=username@domain # 对方收到邮件时显示的发件人 set smtp=smtp.domain.com # 指定第三方发送邮件的smtp服务器地址 set smtp-auth-user=username@domain # 第三方发邮件的用户名 set smtp-auth-password=&amp;#34;password&amp;#34; # 用户名对应密码或授权码 set smtp-auth=login # SMTP的认证方式。默认是LOGIN，也可改为CRAM-MD5或PLAIN方式 Mailx的使用 # 可以使用 mail -h 查看帮助
mail: option requires an argument -- h Usage: mail -eiIUdEFntBDNHRVv~ -T FILE -u USER -h hops -r address -s SUBJECT -a FILE -q FILE -f FILE -A ACCOUNT -b USERS -cUSERS -S OPTION users 无正文的邮件 # mail -s &amp;#34;subject&amp;#34; qs@coderqs.</description></item><item><title/><link>https://coderqs.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%8D%87%E7%BA%A7gcc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%8D%87%E7%BA%A7gcc/</guid><description>升级 GCC # 编译 GCC # 下载源码 # 方法一 # 在 gcc官方镜像下载源码的压缩包
wget http://ftp.gnu.org/gnu/gcc/gcc-8.4.0/gcc-8.4.0.tar.gz tar -zxvf gcc-8.4.0.tar.gz 方法二 # 在 github上载，注意这种方式是展开的源码，文件较多较大，下载时间可能更长
git clone https://github.com/gcc-mirror/gcc.git 安装依赖 # yum install -y gmp gmp-devel mpfr mpfr-devel libmpc libmpc-devel 编译安装 # mkdir gcc-8.4.0-build &amp;amp;&amp;amp; cd gcc-8.4.0-build ../gcc-8.4.0/configure --enable-languages=c,c++ --disable-multilib make -j $(nproc) configure 更多的配置选项在 这里查看
注意：编译之前要保证 /tmp 有足够多的磁盘空间！
安装 # make install 添加环境变量 编译默认的安装路径是 /usr/local/bin, 在 /etc/profile 中追加</description></item><item><title/><link>https://coderqs.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4/%E6%95%85%E9%9A%9C%E8%AE%B0%E5%BD%95/linux%E8%84%9A%E6%9C%AC%E8%87%AA%E5%B7%B1%E5%8F%AF%E4%BB%A5%E5%8D%95%E7%8B%AC%E6%89%A7%E8%A1%8C%E4%BD%86%E5%9C%A8service%E6%96%87%E4%BB%B6%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%B0%B1%E9%94%99%E8%AF%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4/%E6%95%85%E9%9A%9C%E8%AE%B0%E5%BD%95/linux%E8%84%9A%E6%9C%AC%E8%87%AA%E5%B7%B1%E5%8F%AF%E4%BB%A5%E5%8D%95%E7%8B%AC%E6%89%A7%E8%A1%8C%E4%BD%86%E5%9C%A8service%E6%96%87%E4%BB%B6%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%B0%B1%E9%94%99%E8%AF%AF/</guid><description>脚本可单独执行，在 .service 文件中使用就报错 # 背景 # 想要给树莓派添加个服务，每次开机后把 ip 发送到指定邮箱。结果配置好了后总是启动不起来，查看日志发现没有权限 Failed to execute command: Permission denied
-- Unit send_ip.service has begun starting up. Sep 14 16:33:01 bogon systemd[11178]: send_ip.service: Failed to execute command: Permission denied Sep 14 16:33:01 bogon systemd[11178]: send_ip.service: Failed at step EXEC spawning /usr/bin/script/send_ip.sh: Permission denied -- Subject: Process /usr/bin/script/send_ip.sh could not be executed -- Defined-By: systemd -- Support: https://access.redhat.com/support -- -- The process /usr/bin/script/send_ip.sh could not be executed and failed.</description></item><item><title/><link>https://coderqs.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E6%9F%A5%E7%9C%8B%E5%BA%93%E7%9A%84%E7%AC%A6%E5%8F%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E6%9F%A5%E7%9C%8B%E5%BA%93%E7%9A%84%E7%AC%A6%E5%8F%B7/</guid><description>查看库的符号 # 查看生成的so是否存在符号未定义的内容 # ldd -r xxx.so 查看 so 中的所有符号 # nm xxx.so 例如下面是 nm 输出的结果中的一段:
U _ZN11CHttpParser20GetCurrentHttpMethodER13http_method_t U _ZN11CHttpParser26ExactResultFromHttpMsgBodyESsRSs U _ZN11CHttpParser5parseESs U _ZN11CHttpParserC1ESs 00000000000134e6 W _ZN5boost10shared_ptrI11CHttpParserE4swapERS2_ 0000000000012e56 W _ZN5boost10shared_ptrI11CHttpParserEC1ERKS2_ 0000000000012e30 W _ZN5boost10shared_ptrI11CHttpParserEC1Ev 0000000000014cda W _ZN5boost10shared_ptrI11CHttpParserEC1IS1_EEPT_ 0000000000012cda W _ZN5boost10shared_ptrI11CHttpParserED1Ev 0000000000013df4 W _ZN5boost10shared_ptrI11CHttpParserEaSERKS2_ 000000000001348b W _ZN5boost14checked_deleteI11CHttpParserEEvPT_ 其输出的结果是以 地址 类型 符号名 的结构显示的，其中一些常见的符号类型如下
nm输出字符 含义 R Read only symbol. 比如在代码中有一个const MAXDATA = 3095; 则MAXDATA就是一个Read only symbol N 这是一个调试符号 D 这是一个已经初始化的变量的符号。比如代码中int i = 1和char *str = &amp;ldquo;Hello&amp;quot;则i和str都是这种类型的符号 T Text段的符号。子程序都是这种符号，比如文件中实现了一个函数function，则function就是这种符号 U 未定义的符号。如果文件中引用了不存在的函数，则这些未定义的函数符号就是这种类型 S 未初始化的符号，比如全局变量int s;则s的符号就是此类型 参考资料 # Linux下使用nm命令排查和解决“undefined referenceto”</description></item><item><title/><link>https://coderqs.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E8%AE%BE%E7%BD%AE%E7%B3%BB%E7%BB%9F%E6%97%B6%E5%8C%BA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E8%AE%BE%E7%BD%AE%E7%B3%BB%E7%BB%9F%E6%97%B6%E5%8C%BA/</guid><description>方法一：timedatectl # timedatectl 是一个命令行工具，它允许你查看并且修改系统时间和日期。它在所有现代的基于 systemd 的 Linux 系统中都可以使用。
检查时区 # 执行下面命令：
timedatectl 执行后会显示系统的时区。我的机器显示如下：
Local time: Sat 2021-02-19 17:02:22 UTC Universal time: Sat 2021-02-19 17:02:22 UTC RTC time: Sat 2021-02-19 17:02:22 Time zone: UTC (UTC, +0000) System clock synchronized: yes NTP service: active RTC in local TZ: no 可以看到我的机器的时区 Time zone: UTC (UTC, +0000) 是 UTC
修改时区 # 在修改时区时，需要找到想要使用的时区的名字，一般的格式是地区/城市。不知道名字的话可以使用 timedatectl list-timezones 命令来查看，执行后显示如下：
Africa/Abidjan Africa/Accra Africa/Addis_Ababa Africa/Algiers Africa/Asmara .</description></item><item><title/><link>https://coderqs.github.io/%E6%A1%86%E6%9E%B6_%E5%BA%93/jsoncpp%E7%9A%84%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E6%A1%86%E6%9E%B6_%E5%BA%93/jsoncpp%E7%9A%84%E4%BD%BF%E7%94%A8/</guid><description>Jsoncpp 使用方法 # jsoncpp 源码
示例 # 以这个 json 串为例
{ &amp;#34;item_0&amp;#34;:&amp;#34;一个普通的 json 元素&amp;#34;, &amp;#34;arrary&amp;#34;:[&amp;#34;数组元素1&amp;#34;, &amp;#34;数组元素1&amp;#34;], &amp;#34;empty_arrary&amp;#34;:[], &amp;#34;item_1&amp;#34;:{ &amp;#34;item_item_0&amp;#34;:&amp;#34;&amp;#34;, &amp;#34;item_item_1&amp;#34;:&amp;#34;&amp;#34; } } 使用 在线工具检查 json 字符串是否合法，以及格式化、压缩转义等。
解析 json # 示例代码
int ParseJson(std::string json_str) { Json::Reader reader; Json::Value root; try { if (reader.parse(json_str, root)) { if (root.isMember(&amp;#34;item_0&amp;#34;)) std::cout &amp;lt;&amp;lt; root[&amp;#34;item_0&amp;#34;].asString() &amp;lt;&amp;lt; std::endl; if (root.</description></item><item><title/><link>https://coderqs.github.io/%E7%BD%91%E7%BB%9C/%E4%BD%BF%E7%94%A8cloudflare%E5%90%8E%E6%97%A0%E9%99%90%E8%B7%B3%E8%BD%AC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E7%BD%91%E7%BB%9C/%E4%BD%BF%E7%94%A8cloudflare%E5%90%8E%E6%97%A0%E9%99%90%E8%B7%B3%E8%BD%AC/</guid><description>使用 Cloudflare 后网站无限 301 跳转 # 原因分析 # 出现这个故障的大部分服务器都是因为服务器端使用了强制 HTTPS，而 CloudFlare 的 Flexible 策略原理是：用户访问时使用 HTTPS 访问到 CF 的节点，然后 CF 通过HTTP方式回源到你的服务器去读取数据，这个时候对于你的服务器来说，CF 就是访客，所以服务器返回的状态都是 301。
解决方法 # 将 CloudFlare 的 SSL 策略设为 Full 或者 Full(strict) 就能解决。
扩展 # CloudFlare 的 SSL 可选模式 # Off：关闭SSL，全程使用 HTTP； Flexible：A 使用 HTTPS，B 使用 HTTP，称为灵活加密； Full：AB全程使用 HTTPS，允许 B 程服务端使用自签名证书； Full(strict)：全程使用 HTTPS，与 Full 的区别在于服务端必须使用有效的可信任证书； 参考资料 # CDN访问异常篇之重定向的次数过多
Cloudflare开启HTTPS/SSL后无限301跳转的解决方法</description></item><item><title/><link>https://coderqs.github.io/%E7%BD%91%E7%BB%9C/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/v2ray/v2ray%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E7%BD%91%E7%BB%9C/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/v2ray/v2ray%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</guid><description>V2ray 的安装与配置 # V2ray 安装 # 下载安装脚本 # curl -O https://raw.githubusercontent.com/v2fly/fhs-install-v2ray/master/install-release.sh curl -O https://raw.githubusercontent.com/v2fly/fhs-install-v2ray/master/install-dat-release.sh 其中 install-release.sh 用于安装最新版本的 V2ray 的程序，install-dat-release.sh 用于安装geoip.dat和geosite.dat的最新版本。
安装 V2ray # 执行下面命令安装 V2ray
bash install-release.sh 安装的文件结构如下
/usr/local/bin/v2ray /usr/local/bin/v2ctl /usr/local/share/v2ray/geoip.dat /usr/local/share/v2ray/geosite.dat /usr/local/etc/v2ray/config.json /var/log/v2ray/ /var/log/v2ray/access.log /var/log/v2ray/error.log /etc/systemd/system/v2ray.service /etc/systemd/system/v2ray@.service 安装更新 geo 相关的文件
bash install-dat-release.sh 非官方安装脚本 # 脚本的安装命令如下：
wget -P /root -N --no-check-certificate &amp;quot;https://raw.githubusercontent.com/mack-a/v2ray-agent/master/install.sh&amp;quot; &amp;amp;&amp;amp; chmod 700 /root/install.sh &amp;amp;&amp;amp; /root/install.sh 这个脚本在很多教程中看到过，安装起来确实也方便很多，还支持自动配置常用的几种科学上网方式，其支持的安装类型如下
* VLESS+TCP+TLS</description></item><item><title/><link>https://coderqs.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E6%8A%80%E6%9C%AF%E5%BD%92%E7%BA%B3/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E8%A7%84%E8%8C%83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E6%8A%80%E6%9C%AF%E5%BD%92%E7%BA%B3/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E8%A7%84%E8%8C%83/</guid><description>单元测试规范 # 名词解释 # 覆盖率 # 覆盖率是对自动化测试运行期间执行了多少代码产生的度量（100%覆盖意味着每一行代码都至少执行过） 不必追求100%的覆盖率，覆盖率在60%-80%是一个不错的范围，这个主要根据项目的情况来决定。
单元测试原则 # DAMP 和DRY 这是一种平衡，而不是矛盾
DAMP 和 DRY 并不矛盾，而是平衡了代码可维护性的两个不同方面。可维护的代码（易于更改的代码）是这里的最终目标。
DAMP（描述性和有意义的短语）提高了代码的可读性。
要维护代码，首先需要了解代码。要理解它，你必须阅读它。考虑一下你花多少时间阅读代码。这是很多。 DAMP 通过减少阅读和理解代码所需的时间来提高可维护性。
DRY（不要重复自己）促进代码的 正交性。
删除重复确保系统中的每个概念在代码中都有一个单一的权威表示。对单个业务概念的更改会导致对代码的一次更改。DRY 通过将更改（风险）隔离到系统中必须更改的那些部分来提高可维护性。
那么，为什么重复在测试中更容易接受？
测试通常包含固有的重复，因为它们一遍又一遍地测试相同的东西，只是输入值或设置代码略有不同。但是，与生产代码不同的是，这种重复通常仅与单个测试夹具/文件中的场景隔离。因此，重复是最小的和明显的，这意味着它比其他类型的重复给项目带来的风险更小。
此外，删除这种重复会降低测试的可读性。以前在每个测试中重复的细节现在隐藏在一些新方法或类中。为了全面了解测试，您现在必须在精神上将所有这些部分重新组合在一起。
因此，由于测试代码重复通常带来的风险较小，并提高了可读性，因此很容易看出它是如何被认为是可以接受的。
原则上，在生产代码中使用 DRY，在测试代码中使用 DAMP。虽然两者同等重要，但只要稍加智慧，您就可以在对自己有利的情况下平衡。
引用自： 在谈论单元测试时，&amp;ldquo;DAMP not DRY&amp;quot;是什么意思？
单元测试的准则 # 单元测试应该是可靠的，否则不能保证测试结果可信; 单元测试应该是可维护且易于阅读和理解的; 单元测试的每一个测试单元只测试一个用例，这样便于维护; 单元测试应该可以在任何机器上顺序运行，且不会相互影响，如果可以，希望也能不依赖环境因素或全局/外部状态; 单元测试应该自动化; 结合使用单元测试和集成测试; 单元测试应在有组织的测试实践中执行; 单元测试用例的命名方法 # 这里提供以下七种命名方法以供参考
MethodName_StateUnderTest_ExpectedBehavior(方法名_在测试状态_预期行为) # 如果方法名在重构的时候被更改，那么测试用例也应该同样被更改，否则以后会难以被理解。示例：
isAdult_AgeLessThan18_False
withdrawMoney_InvalidAccount_ExceptionThrown
admitStudent_MissingMandatoryFields_FailToAdmit
MethodName_ExpectedBehavior_StateUnderTest(方法名_预期行为_在测试状态) # 与第一种有相同的问题。示例：</description></item><item><title/><link>https://coderqs.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E6%8A%80%E6%9C%AF%E5%BD%92%E7%BA%B3/%E7%89%88%E6%9C%AC%E5%8F%B7%E7%9A%84%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E6%8A%80%E6%9C%AF%E5%BD%92%E7%BA%B3/%E7%89%88%E6%9C%AC%E5%8F%B7%E7%9A%84%E7%AE%A1%E7%90%86/</guid><description>版本号的管理 # 前言 # 在现代软件开发过程中，相较于“重复造轮子”，开发者往往会利用一些已有的组件（如库、程序、多媒体文件）进行开发。程序开发者根据特定版本的组件来设计自己的软件。这种方式使得代码重复利用，减少了开发的工作量，降低了开发门槛。但是该软件要正确运行，必须安装了指定版本的某些组件。
==== 依赖地狱 ==== 操作系统中由于软件之间的依赖性不能被满足而引发的问题称为依赖地狱。依赖地狱主要有以下表现：
依赖过多：一个软件包可能依赖于众多的库，因此安装一个软件包的同时要安装几个甚至几十个库包。 # 多重依赖：指从所需软件包到最底层软件包之间的层级数过多。这会导致依赖性解析过于复杂，并且容易产生依赖冲突和环形依赖。 # 依赖冲突：即两个软件包无法共存的情况。除两个软件包包含内容直接冲突外，也可能因为其依赖的低层软件包互相冲突。因此，两个看似毫无关联的软件包也可能因为依赖性冲突而无法安装。 依赖循环：即依赖性关系形成一个闭合环路，最终导致：在安装 A 软件包之前，必须要安装 A、B、C、D 软件包，然而这是不可能的。 版本号风格总结 # GUN 风格 # 命名格式 # 主版本号 . 子版本号 [. 修正版本号 build- [编译版本号 ]]
示例：
1.2 1.2.0 1.2.0 build-1234 规范 # 项目初版本时，版本号可以是 0.1 或 0.1.0，可以是 1.0 或 1.0.0，建议主版本号从 0 开始; 当项目在进行了局部修改或 bug 修正时，主版本号和子版本号都不变，修正版本号加 1; 当项目在原有的基础上增加了部分功能时，主版本号不变，子版本号加 1，修正版本号复位为 0，因而可以被忽略掉; 当项目在进行了重大修改或局部修正累积较多，而导致项目整体发生全局变化时，主版本号加 1; 编译版本号一般是编译器在编译过程中自动生成的，我们只定义其格式，并不进行人为控制; Windows 风格 # 命名格式 # 主版本号 .</description></item><item><title/><link>https://coderqs.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E6%8A%80%E6%9C%AF%E5%BD%92%E7%BA%B3/%E7%BC%96%E7%A0%81%E8%A7%84%E5%88%99/cpp%E6%B3%A8%E9%87%8A%E9%A3%8E%E6%A0%BC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E6%8A%80%E6%9C%AF%E5%BD%92%E7%BA%B3/%E7%BC%96%E7%A0%81%E8%A7%84%E5%88%99/cpp%E6%B3%A8%E9%87%8A%E9%A3%8E%E6%A0%BC/</guid><description>C++ 注释风格 # 个人比较认同的三种注释风格
doxygen 风格 # 指的是 doxygen 或者基于 doxygen 语法的一些变体的注释。
这种注释好处是可以直接使用 doxygen 的工具生成文档，但坏处就是太啰嗦，而且这种注释大家在修改代码的时候多数都懒得修改，容易造成注释与代码对不上的情况。
rustdoc 风格 # rustdoc 所推荐的注释风格，直接在 /// 型的注释里使用 markdown 语法写注释即可。
这种注释书写起来很方便，但需要了解 markdown 的语法，对经常使用 markdown 的人员来说非常直观。
简约风格 # 这种风格提倡在代码中使用良好的命名使代码具有自解释性，以此来适当的减少描述性的注释出现，避免造成代码的不连续。
这种注释对于命名的能力有着较高要求，毕竟在开发过程中能起一个准确又合适的名字不是一件简单的事情，但是这种风格的代码在看的时候很舒服的。
使用这种风格有以下几个注意点与建议：
规范、准确的命名。 区分使用代码注释 /**/ (只注释代码) 与说明注释 /// () 减少多行注释，允许的情况下与代码同行。 参考资料 # C++注释规范是什么？</description></item><item><title/><link>https://coderqs.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E6%8A%80%E6%9C%AF%E5%BD%92%E7%BA%B3/%E7%BC%96%E7%A0%81%E8%A7%84%E5%88%99/cpp%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E6%8A%80%E6%9C%AF%E5%BD%92%E7%BA%B3/%E7%BC%96%E7%A0%81%E8%A7%84%E5%88%99/cpp%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC/</guid><description>C++ 编码风格 # 这是基于 Google 发布的 C++ 编程风格指南整理的，每一项规则的详细的阐述可以参见 官方的原版指南或者 中文版。
注意：这份指南只是提供了一份通用的编程规范，当你的项目已有自己的约定则优先遵守项目的约定！
头文件 # 通常一个一个 .cc 对应一个 .h，但也有一些常见的例外，例如单元测试代码只有 .cc 文件和 main() 函数。
Self-contained 头文件 # 头文件，以 .h 结尾; 用于插入文本的文件，以 .inc 结尾; 模板或内联函数的定义不要放到 -inl.h 文件中; 不建议从 .h 中分离出 -inl.h 文件; #define 保护 # 所有头文件都应该使用 #define 来防止头文件被多重包含, 命名格式当是: &amp;lt;PROJECT&amp;gt;_&amp;lt;PATH&amp;gt;_&amp;lt;FILE&amp;gt;_H_（路径是从项目的源代码树的根路径开始）。
前置声明 # 尽可能地避免使用前置声明。使用 #include 包含需要的头文件即可。
尽量避免前置声明那些定义在其他项目中的实体; 函数：总是使用 #include; 类模板：优先使用 #include; 内联函数 # 不要内联超过 10 行的函数; 不要内联包含循环或 switch 语句的函数; 虚函数和递归函数不应该声明成内联; #include 的路径及顺序 # 避免使用特殊的快捷目录 .</description></item><item><title/><link>https://coderqs.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E6%8A%80%E6%9C%AF%E5%BD%92%E7%BA%B3/%E7%BC%96%E7%A0%81%E8%A7%84%E5%88%99/%E5%B7%A5%E7%A8%8B%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E6%8A%80%E6%9C%AF%E5%BD%92%E7%BA%B3/%E7%BC%96%E7%A0%81%E8%A7%84%E5%88%99/%E5%B7%A5%E7%A8%8B%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</guid><description>工程目录结构 # 目前这份结构只考虑了 C/C++ 的工程
project_root |- 3rdparty |- builds(platforms) |- cmake |- bin |- lib |- include |- project_name |- module_1 |- module_2 |- config |- readme.md |- data |- test |- sample |- scripts |- doc readme.md: 自述文件。 3rdparty: 第三方库的源代码。以子项目(git submodule)的形式存在，如果没有则不需要这文件夹。 data: 存放测试数据，可以没有。 test: 存放单元测试代码，其内部层级结构与 src 一致。 sample: 存放示例代码。 doc: 存放文档（如果文档全上 wiki 这个是不是可以不要？）。 builds(platforms): 构建系统，里面根据不同平台再划分一级目录，分别存放对应的 构建脚本(cmake、makefile 等)。 cmake: 存放 .cmake 文件，不使用 cmake 可以不要这个目录 project_name: 总源码目录，内部分模块组织。 * 每个模块放在同名的文件夹下，模块内部存放该模块的主要功能逻辑代码，但不可以出现模块嵌套的情况。 * 包含内部头文件时，要从 ''project_name'' 开拼写完整路径，防止头文件名称冲突，遵循 google c++ 编码规范。 * ''config'': 存放配置文件模板。 * ''scripts'': 存放脚本文件，如发布脚本。 * ''include'': 第三方库的头文件。 * ''lib'': 三/二方库的库文件。 * ''bin'': 工程的输出目录。</description></item><item><title/><link>https://coderqs.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E6%8A%80%E6%9C%AF%E5%BD%92%E7%BA%B3/%E7%BC%96%E8%AF%91%E6%9C%BA%E7%8E%AF%E5%A2%83%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E6%8A%80%E6%9C%AF%E5%BD%92%E7%BA%B3/%E7%BC%96%E8%AF%91%E6%9C%BA%E7%8E%AF%E5%A2%83%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95/</guid><description>编译机环境管理方法 # 以用户的方式管理 # 说明 # 创建一个compiler用户 这个用户用于系统默认编译器的的编译 该用户的家目录下存放所有代码 所有添加的其他编译用户都处于compiler中户组（给compiler设置 SGID 可以使其下面的文件夹都默认处于compiler组里） 该用户家目录的所有代码都要给组用户写权限 创建用户，以 NDK 为例，%%android-ndk-r13b-linux-x86_64 对应的用户名 android-ndk-r13 将编译器安装在对应的用户家目录中 将需要的环境变量配置在用户的.bash_prefile中 配置umask，给组与用户同样的权限 演示配置 android-ndk-r13 用户 # # adduser android-ndk-r13 -g compiler # echo &amp;quot;umask 002&amp;quot; &amp;gt;&amp;gt; /home/android-ndk-r13/.bashrc # su - android-ndk-r13 # unzip android-ndk-r13b-linux-x86_64.zip 配置环境变量 # 在~/bash_prefile中添加下面
export NDKROOT=/home/android-ndk-r13/android-ndk-r13b export PATH=$NDKROOT:$PATH INSTALLATION_PATH=/home/output/android-ndk-r13 export prefix=$INSTALLATION_PATH export ANDROID_HOME=~/android-ndk-r13b export TOOLCHAIN=$ANDROID_HOME/android-toolchain export CROSS_SYSROOT=$TOOLCHAIN/sysroot export PATH=$TOOLCHAIN/bin:$PATH export TOOL=arm-linux-androideabi export CC=$TOOLCHAIN/bin/${TOOL}-gcc export CXX=$TOOLCHAIN/bin/${TOOL}-g++ export LINK=${CXX} export LD=$TOOLCHAIN/bin/${TOOL}-ld export AR=$TOOLCHAIN/bin/${TOOL}-ar export RANLIB=$TOOLCHAIN/bin/${TOOL}-ranlib export STRIP=$TOOLCHAIN/bin/${TOOL}-strip export ARCH_FLAGS=&amp;#34;-mthumb&amp;#34; export ARCH_LINK= export CFLAGS=&amp;#34;${ARCH_FLAGS}-fpic -ffunction-sections -funwind-tables -fstack-protector -fno-strict-aliasing -finline-limit=64&amp;#34; export CXXFLAGS=&amp;#34;${CFLAGS}-frtti -fexceptions&amp;#34; export LDFLAGS=&amp;#34;${ARCH_LINK}&amp;#34; 参考资料 # linux下如何实现不同的用户对同一文件都有写权限</description></item><item><title/><link>https://coderqs.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/markdown/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/markdown/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</guid><description>&amp;lt;markdown&amp;gt; # Markdown 语法指南
Markdown是为网络书写者而生的方便“text-to-HTML”工具，它允许人们用一种易读易写的纯文本格式进行书写，然后将其转化成XHTML（或HTML）。
&amp;gt;
Markdown 的特点是“易读易写”，其中可读性是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。
&amp;gt;
Markdown 语法的目标是：成为一种适用于网络的书写语言。
&amp;gt;
Markdown 不是想要取代 HTML，甚至也没有要和它相近，它的语法种类很少，只对应 HTML 标记的一小部分。Markdown 的构想不是要使得 HTML 文档更容易书写。在我看来， HTML 已经很容易写了。Markdown 的理念是，能让文档更容易读、写和随意改。HTML 是一种发布的格式，Markdown 是一种书写的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围。
—— John Gruber
## 简介
## 文字的基本格式 ### 倾斜 前后各一个 `*` （星号）或 `_` （下划线符）包围的文本是倾斜文本。 `*倾斜*` *倾斜* `_倾斜_` _倾斜_ 但不能`*` 和 `_` 一样一个的混用，像这样 `*倾斜_`
### 加粗 前后各两个 `*` （星号）或 `_` （下划线符）包围的文本是倾斜文本。 `加粗` 加粗 `加粗` 加粗</description></item><item><title/><link>https://coderqs.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E7%89%B9%E5%AE%9A%E9%A2%86%E5%9F%9F%E8%AF%AD%E8%A8%80/shell/shell%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E7%89%B9%E5%AE%9A%E9%A2%86%E5%9F%9F%E8%AF%AD%E8%A8%80/shell/shell%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</guid><description>Shell 基础语法 # 注释 # 单行注释 # 使用 #
# echo &amp;#34;hello&amp;#34; 多行注释 # 方法一 # : &amp;lt;&amp;lt; ! 这是注释1 这是注释2 这是注释3 ! 方法二 # :&amp;#39; 这是注释1 这是注释2 这是注释3 &amp;#39; 方法三 # : &amp;lt;&amp;lt; 字符 #这里的字符可以是数字或者是字符都可以 这是注释1 这是注释2 这是注释3 字符 #这里的字符要和一开始的一样 方法四 # if false; then 这是注释1 这是注释2 这是注释3 fi 方法五 # ((0))&amp;amp;&amp;amp;{ 这是注释1 这是注释2 这是注释3 } 参考资料 # shell中的单行注释和多行注释</description></item><item><title/><link>https://coderqs.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/c_cpp/errno%E9%94%99%E8%AF%AF%E7%A0%81%E8%AF%B4%E6%98%8E/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/c_cpp/errno%E9%94%99%E8%AF%AF%E7%A0%81%E8%AF%B4%E6%98%8E/</guid><description>errno 错误码说明 关于 errno 的相关定义都在头文件 # /usr/include/asm/errno.h 中，下面是从文件中拷出来方便查询
#define EPERM 1 /* Operation not permitted */操作不允许 #define ENOENT 2 /* No such file or directory */文件/路径不存在 #define ESRCH 3 /* No such process */进程不存在 #define EINTR 4 /* Interrupted system call */中断的系统调用 #define EIO 5 /* I/O error */I/O错误 #define ENXIO 6 /* No such device or address */设备/地址不存在 #define E2BIG 7 /* Arg list too long */参数列表过长 #define ENOEXEC 8 /* Exec format error */执行格式错误 #define EBADF 9 /* Bad file number */错误文件编号 #define ECHILD 10 /* No child processes */子进程不存在 #define EAGAIN 11 /* Try again */重试 #define ENOMEM 12 /* Out of memory */内存不足 #define EACCES 13 /* Permission denied */无权限 #define EFAULT 14 /* Bad address */地址错误 #define ENOTBLK 15 /* Block device required */需要块设备 #define EBUSY 16 /* Device or resource busy */设备或资源忙 #define EEXIST 17 /* File exists */文件已存在 #define EXDEV 18 /* Cross-device link */跨设备链路 #define ENODEV 19 /* No such device */设备不存在 #define ENOTDIR 20 /* Not a directory */路径不存在 #define EISDIR 21 /* Is a directory */是路径 #define EINVAL 22 /* Invalid argument */无效参数 #define ENFILE 23 /* File table overflow */文件表溢出 #define EMFILE 24 /* Too many open files */打开的文件过多 #define ENOTTY 25 /* Not a typewriter */非打字机 #define ETXTBSY 26 /* Text file busy */文本文件忙 #define EFBIG 27 /* File too large */文件太大 #define ENOSPC 28 /* No space left on device */设备无空间 #define ESPIPE 29 /* Illegal seek */非法查询 #define EROFS 30 /* Read-only file system */只读文件系统 #define EMLINK 31 /* Too many links */链接太多 #define EPIPE 32 /* Broken pipe */管道破裂 #define EDOM 33 /* Math argument out of domain of func */参数超出函数域 #define ERANGE 34 /* Math result not representable */结果无法表示 #define EDEADLK 35 /* Resource deadlock would occur */资源将发生死锁 #define ENAMETOOLONG 36 /* File name too long */文件名太长 #define ENOLCK 37 /* No record locks available */没有可用的记录锁 #define ENOSYS 38 /* Function not implemented */函数未实现 #define ENOTEMPTY 39 /* Directory not empty */目录非空 #define ELOOP 40 /* Too many symbolic links encountered */遇到太多符号链接 #define EWOULDBLOCK EAGAIN /* Operation would block */ 操作会阻塞 #define ENOMSG 42 /* No message of desired type */没有符合需求类型的消息 #define EIDRM 43 /* Identifier removed */标识符已删除 #define ECHRNG 44 /* Channel number out of range */通道编号超出范围 #define EL2NSYNC 45 /* Level 2 not synchronized */level2不同步 #define EL3HLT 46 /* Level 3 halted */3级停止 #define EL3RST 47 /* Level 3 reset */3级重置 #define ELNRNG 48 /* Link number out of range */链接编号超出范围 #define EUNATCH 49 /* Protocol driver not attached*/协议驱动程序没有连接 #define ENOCSI 50 /* No CSI structure available*/没有可用的CSI结构 #define EL2HLT 51 /* Level 2 halted */2级停止 #define EBADE 52 /* Invalid exchange */无效交换 #define EBADR 53 /* Invalid request descriptor */无效请求描述 #define EXFULL 54 /* Exchange full */交换完全 #define ENOANO 55 /* No anode */无阳极 #define EBADRQC 56 /* Invalid request code */无效请求码 #define EBADSLT 57 /* Invalid slot */无效插槽 #define EDEADLOCK EDEADLK #define EBFONT 59 /* Bad font file format */错误的字体文件格式 #define ENOSTR 60 /* Device not a stream */设备不是流 #define ENODATA 61 /* No data available */无数据 #define ETIME 62 /* Timer expired */计时器到期 #define ENOSR 63 /* Out of streams resources */流资源不足 #define ENONET 64 /* Machine is not on the network */机器不在网络上 #define ENOPKG 65 /* Package not installed */包未安装 #define EREMOTE 66 /* Object is remote */对象是远程 #define ENOLINK 67 /* Link has been severed */链接正在服务中 #define EADV 68 /* Advertise error */广告错误 #define ESRMNT 69 /* Srmount error */？ #define ECOMM 70 /* Communication error on send */发送过程中通讯错误 #define EPROTO 71 /* Protocol error */协议错误 #define EMULTIHOP 72 /* Multihop attempted */多跳尝试 #define EDOTDOT 73 /* RFS specific error */RFS特定错误 #define EBADMSG 74 /* Not a data message */不是数据类型消息 #define EOVERFLOW 75 /* Value too large for defined data type */对指定的数据类型来说值太大 #define ENOTUNIQ 76 /* Name not unique on network */网络上名字不唯一 #define EBADFD 77 /* File descriptor in bad state */文件描述符状态错误 #define EREMCHG 78 /* Remote address changed */远程地址改变 #define ELIBACC 79 /* Can not access a needed shared library */无法访问需要的共享库 #define ELIBBAD 80 /* Accessing a corrupted shared library */访问损坏的共享库 #define ELIBSCN 81 /* .</description></item><item><title/><link>https://coderqs.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/c_cpp/gnu%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E6%8D%A2%E5%90%8D%E8%A7%84%E5%88%99/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/c_cpp/gnu%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E6%8D%A2%E5%90%8D%E8%A7%84%E5%88%99/</guid><description>GNU C++ 编译器的换名规则 # 全局变量 # 不做任何修改
全局函数 # 以_Z开头，然后是函数名字符的个数，接着是函数名，最后是函数参数的别名。
类或命名空间中的变量或函数 # 以_ZN开头，然后是变量或函数所在名字空间或类名字的字符长度，然后接着的是真正的名字空间或类名，然后是变量或函数名的长度和变量或函数名，后面紧跟字母E，最后如果是函数的话则跟参数别名，如果是变量则什么都不用加。
构造函数和析构函数 # 以_ZN开头，然后是构造函数所在名字空间和类名字的字符长度，然后接着的是真正的名字空间或类名，然后构造函数接C1或者C2，析构函数接D1或者D2，然后加上字母E，最后接函数参数别名结束。
函数的参数 # 是基本类型时 # 参数类型 参数别名 void v wchar_t w bool b char c signed char a unsigned char h short s unsigned short t int i unsigned int j long l unsigned long m long long或__int64 x unsigned long long或unsigned __int64 y __int128 n unsigned __int128 o float f double d long double或__float80 e __float128 g 是类或结构体时 # 在类或者结构体名字前加上类或结构体名的字符长度</description></item><item><title/><link>https://coderqs.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/c_cpp/%E9%94%99%E8%AF%AF%E5%BD%92%E7%BA%B3/%E7%BC%96%E8%AF%91%E7%9B%B8%E5%85%B3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/c_cpp/%E9%94%99%E8%AF%AF%E5%BD%92%E7%BA%B3/%E7%BC%96%E8%AF%91%E7%9B%B8%E5%85%B3/</guid><description>C++ 编译相关的错误整理 # undefined reference to XXX # 这是非常常见的一个问题，原因差不多有以下三点：
编译器找不到定义了XXX的文件; 定义了XXX的文件，由于函数修饰的原因里面没有想要的XXX符号; 找到了想要的符号，但是该符号是隐藏属性，不能链接使用;
详细的解释与解决方法请查看参考资料。 参考资料 # &amp;ldquo;undefined reference to XXX&amp;rdquo; 问题总结
expected primary-expression before xx token # 这里的 xx 指的是一半都是运算符，比如 ++，— 等
** 示例 ** expected primary-expression before ')' token
** 原因 ** 把类型(type)当成变量来用了(variable)
** 参考资料 ** expected primary-expression before xx token 错误处理
expected unqualified-id before &amp;lsquo;(&amp;rsquo; token # ** 原因 ** 头文件的引用顺序引起的，只需要调整引用该头文件的其他文件在报错的 .</description></item><item><title/><link>https://coderqs.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/python/%E5%86%85%E7%BD%AE%E9%94%99%E8%AF%AF%E9%9B%86%E5%90%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/python/%E5%86%85%E7%BD%AE%E9%94%99%E8%AF%AF%E9%9B%86%E5%90%88/</guid><description>Python 内置错误集合 # BaseException—&amp;gt;所有异常的基类 # *SystemExit: 解释器请求退出 \\ *KeyboardInterrupt: 用户中断执行(输入) \\ *GeneratorExit: 生成器发生异常通知退出 \\ Exception—&amp;gt;常规异常的基类 # *StopIteration: 迭代器没有更多的值\\ *StopAsyncIteration: 必须通过异步迭步器''__anext__()''方法引发以停止迭代 \\ ArithmeticError—&amp;gt;各种运算错误异常的基类 # *FloatingPointError: 浮点计算错误 \\ *OverflowError: 数值运算结果太大无法表示 \\ *ZeroDivisionError: 除法或模运算的第二个自变量为零 \\ *AssertionError: assert(断言)语句失败时\\ *AttributeError: 属性引用或赋值失败\\ *BufferError: 无法执行与缓存区相关的操作\\ *EOFError: 当input()函数达到文件结束条件(EOF)而不读取任何数据时 ImportError—&amp;gt;导入模块或对象失败 # *ModuleNotFoundError: 无法找到要导入的模块 LookupError—&amp;gt;映射或序列上使用的键或索引无效的基类 # *IndexError: 序列下标超出范围\\ *KeyError: 在现有键集中找不到映射(字典)的键\\ *MemoryError: 操作内存不足 NameError—&amp;gt;未声明/初始化对象 # *UnboundLocalError: 访问未初始化的本地变量 OSError—&amp;gt;操作系统错误 # *BlockingIOError: 操作将阻塞对象设置为非阻塞操作\\ *ChildProcessError: 子进程上的操作失败 ConnectionError—&amp;gt;与连接相关的异常的基类 # *BrokenPipeError: 另一端关闭时尝试写入管道或试图在已关闭写入的套接字上写入\\ *ConnectionAbortedError: 等方终止连接尝试\\ *ConnectionRefusedError: 等端拒绝连接尝试\\ *ConnectionResetError: 等方重置连接\\ *FileExistsError: 尝试创建已经存在的文件或目录\\ *FileNotFoundError: 请求文件或目录但不存在\\ *InterruptedError: 系统调用被传入信号中断\\ *IsADirectoryError: 在目录上请求文件操作 (例如os.</description></item><item><title/><link>https://coderqs.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/python/%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/python/%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/</guid><description>Python 编译安装 # 准备 # 访问 官网找到对应版本（以Python 3.6.5为例）如图：
下载命令：
wget https://www.python.org/ftp/python/3.6.5/Python-3.6.5.tgz 安装 # 解压 # tar -zxvf Python-3.6.5.tgz 准备编译环境 # yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc make 如果python是3.7版本，还需要安装 libffi-devel
编译 # cd Python-3.6.5 ./configure --prefix=/usr/bin/python-3.6.5 &amp;amp;&amp;amp; make &amp;amp;&amp;amp; make install 其中 --prefix 是 Python 的安装目录，安装成功后如图所示:
从图中可以看出也同时安装了 setuptools 和 pip 工具
创建软连接 # ln -s /usr/bin/python-3.</description></item><item><title/><link>https://coderqs.github.io/%E8%AE%BE%E5%A4%87/%E6%A0%91%E8%8E%93%E6%B4%BE/%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E8%AE%BE%E5%A4%87/%E6%A0%91%E8%8E%93%E6%B4%BE/%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4/</guid><description>&amp;lt;markdown&amp;gt; # 使用树莓派遇见的一些问题的解决方法 ## 不能进入系统 Failed to load SELinux policy. Freezing ### 背景 想关闭 SELinux 结果改错配置项了，导致系统启动时一直提示`Failed to load SELinux policy. Freezing`就是进不去系统。现在进不去系统，配置文件也没法修改，也不想重装系统，遂在网上找了各种方法 1. windows下倒是可以使用DiskGenius来访问ext4格式的文件系统，但是写入的功能是收费的，也没找到破解版，其他软件只支持读取不支持写入； 2. 进入grub编辑的方法我是没弄成功；
后来突然想到挂载到虚拟机上试试，结果还真成功了，所以在此记录下。
### 原因 永久关闭 SELinux 时配置错了，应修改的是`/etc/selinux/config`中的`SELINUX`项改为`disabled`，结果错改了`SELINUXTYPE`项，原始配置如下 ``` # This file controls the state of SELinux on the system. # SELINUX= can take one of these three values: # enforcing - SELinux security policy is enforced. # permissive - SELinux prints warnings instead of enforcing. # disabled - No SELinux policy is loaded.</description></item><item><title/><link>https://coderqs.github.io/%E8%AE%BE%E5%A4%87/%E6%A0%91%E8%8E%93%E6%B4%BE/%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%83%A7%E5%BD%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E8%AE%BE%E5%A4%87/%E6%A0%91%E8%8E%93%E6%B4%BE/%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%83%A7%E5%BD%95/</guid><description>树莓派系统的烧录 # 环境准备 # 系统镜像 # 树莓派有专用的系统 raspbian 可以在其 官网下载。不过我要使用的是 Centos7，系统文件可在其官网的 下载页面进行下载，注意一定要下载 ARM 版本。
使用的工具 # SD Memory Card formatter # 这个是用于格式 SD 卡的，它有 Windows 版和 Mac 版，我使用的是 Windows 版。
win32diskimager # 这个是用于向 SD 卡烧录系统的，在其 官网下载最新的稳定版就可以，我是用的是 1.0.0 版本。
烧录 # 格式化 TF 卡 # 将卡连接到电脑上，打开 SD Memory Card formatter。在上面选择要格式化的 TF 卡，其他配置不用调，点击 Format
烧录系统 # 打开 win32diskimager 在上面选择刚下载的 CentOS 的映像文件，注意旁边的设备不要选错，然后点击写入
烧录好系统后，在我的电脑可以看到 TF 卡变成一个只有几十 M 的 boot 盘</description></item><item><title/><link>https://coderqs.github.io/%E8%AE%BE%E5%A4%87/%E8%B7%AF%E7%94%B1%E5%99%A8/%E5%B0%8F%E7%B1%B3%E8%B7%AF%E7%94%B1%E5%99%A8_mini_%E5%88%B7_openwrt/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E8%AE%BE%E5%A4%87/%E8%B7%AF%E7%94%B1%E5%99%A8/%E5%B0%8F%E7%B1%B3%E8%B7%AF%E7%94%B1%E5%99%A8_mini_%E5%88%B7_openwrt/</guid><description>====== 小米路由器 mini 刷 openwrt ======
将系统刷成开发版 # 在 MiWiFi 下载路由器对应的 ROM 开发版，版本 2.21.109 安装 miwifi_ssh # 在 MiWiFi 开发页面点击 “开启 SSH 工具” 下载 SSH 工具 miwifi_ssh.bin 将路由器绑定小米账号后，在页面会显示 root 的密码 将 miwifi_ssh.bin 放入 U 盘，删除 U 盘上的其他文件，其他操作与刷 ROM 一致 刷成 OpenWrt # 在 OpenWrt 的官网下载对应版本的固件，我的是 小米路由器 MINI，其他型号的路由器可以在官网的 Table of Hardware: Firmware downloads中搜索下载
scp openwrt*.bin root@192.168.31.1:/tmp cd /tmp mtd -r write openwrt*.bin firmware 如遇以下报错，改 firmware 为 OS1 即可</description></item><item><title>Let's Encrypt 免费 SSL 证书申请与续期</title><link>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E5%85%B6%E4%BB%96/let_s_encrypt%E5%85%8D%E8%B4%B9ssl%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7%E4%B8%8E%E7%BB%AD%E6%9C%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E5%85%B6%E4%BB%96/let_s_encrypt%E5%85%8D%E8%B4%B9ssl%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7%E4%B8%8E%E7%BB%AD%E6%9C%9F/</guid><description>Let&amp;rsquo;s Encrypt 免费 SSL 证书申请与续期 # Let&amp;rsquo;s Encrypt 是一个于2015年三季度推出的数字证书认证机构，旨在以自动化流程消除手动创建和安装证书的复杂流程，并推广使万维网服务器的加密连接无所不在，为安全网站提供免费的传输层安全性协议（TLS）证书。
Let&amp;rsquo;s Encrypt 由互联网安全研究小组（缩写 ISRG）提供服务。主要赞助商包括电子前哨基金会、Mozilla 基金会、Akamai 以及思科。2015年4月9日，ISRG 与 Linux 基金会宣布合作。
Let&amp;rsquo;s Encrypt 宣称这一过程将十分简单、自动化并且免费。
安装 certbot # certbot 是 Let&amp;rsquo;s Encrypt 的客户端。我的系统是 Centos，使用的是下面的命令
yum install -y certbot 使用 certbot --version 查看版本显示
certbot 1.12.0 是此时的最新版。如果不是还可以使用手动安装的方式，在 这里下载最新的发布包解压即可。
申请 ssl 证书 # 申请的命令格式一般是
certbot certonly -d &amp;#34;*.youdomain.com&amp;#34; --manual --preferred-challenges dns-01 --server https://acme-v02.api.letsencrypt.org/directory 其中：
certonly，表示使用的插件，Certbot 有很多插件。不同的插件都可以申请证书，这个可以根据需要自行选择。 -d，为哪些主机申请证书。如果是通配符，输入 *.youdomain.com（根据实际情况替换为你自己的域名）。 –preferred-challenges，使用 DNS 方式校验域名所有权。注：申请通配符证书，只能使用 dns-01 的方式。 –server，Let’s Encrypt ACME v2 版本使用的服务器不同于 v1 版本，需要显示指定 我使用的命令的是</description></item><item><title>Linux 下的问题及解决方法 - 系统相关</title><link>https://coderqs.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4/%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4/%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/</guid><description>Linux 系统相关的问题及解决方法 # 防火墙已开启但没有开放 22 端口，却依然可以使用 ssh 连接 # 原因 # 防火墙开放了 ssh 服务，服务把 22 端口开放了。相关的操作可参考防火墙的 firewalld的规则配置#服务管理
ifconfig 获取不到ip # 原因 # NetworkManager 断开或没有管理网卡设备。使用 nmcli d status 可以查看 NetworkManager 状态。添加管理和启动的方法请查看《 CentOS7重启后dhclient未运行，导致IP未获取问题处理》
systemctl 报错 code=exited status=203 # 原因 # systemctl 执行脚本时需要知道脚本的解释器。
解决方法 # 脚本启动命令前指定脚本的解释器，可以参考实例记录: linux脚本自己可以单独执行但在service文件中使用就错误。</description></item><item><title>Linux 下的问题及解决方法 - 用户相关"</title><link>https://coderqs.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4/%E7%94%A8%E6%88%B7%E7%9B%B8%E5%85%B3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4/%E7%94%A8%E6%88%B7%E7%9B%B8%E5%85%B3/</guid><description>Linux 下用户相关的的问题解决方法 # 登录用户出现-bash-4.2$ # 原因 # 用户家目录下的环境变量文件（.bash_profile 和 .bashrc）丢失了
解决方法 # 从主默认文件/etc/skel/下重新拷贝一份配置信息到此用户的家目录下，命令如下
cp /etc/skel/.bashrc /home/user/ cp /etc/skel/.bash_profile /home/user 拷贝完后注销并重新登录用户即可。</description></item><item><title>OpenSSL 自签证书</title><link>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E5%85%B6%E4%BB%96/openssl%E8%87%AA%E7%AD%BE%E8%AF%81%E4%B9%A6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E5%85%B6%E4%BB%96/openssl%E8%87%AA%E7%AD%BE%E8%AF%81%E4%B9%A6/</guid><description>OpenSSL 自签证书 # 检查OpenSSL # 检查是否已经安装openssl：
openssl version 一般情况下系统会默认安装。
生成自签名的SSL证书和私钥 # 1. 生成私钥 # openssl genrsa -des3 -out server.pass.key 2048 参数解析:
genra 生成RSA私钥 -des3 des3算法 -out server.key 生成的私钥文件名 2048 私钥长度 2. 去除私钥中的密码 # openssl rsa -in server.pass.key -out server.key 注意：有密码的私钥是server.pass.key，没有密码的私钥是server.key
3. 生成CSR(证书签名请求) # openssl req -new -key server.key -out server.csr -subj &amp;#34;/C=CN/ST=Guangdong/L=Guangzhou/O=xdevops/OU=xdevops/CN=gitlab.xdevops.cn&amp;#34; req 生成证书签名请求 -new 新生成 -key 私钥文件 -out 生成的CSR文件 -subj 生成CSR证书的参数 subj 参数说明如下：</description></item><item><title>Pandoc</title><link>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E5%85%B6%E4%BB%96/pandoc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E5%85%B6%E4%BB%96/pandoc/</guid><description>Pandoc # 提供多种标记语言之间的转换的功能，但不完全是双向的，部分是单向的，可转换的关系请参考 此页面。
使用 # 较短的文字可以使用 在线版来转换，文字过长就需要 下载客户端来转换。
markdown 转 dokuwiki # pandoc -f markdown_github -t dokuwiki in_filename.md -o out_filename.txt 注：markdown 的语法分支比较多，要选对自己使用的是那种 markdown 语法。
参考资料 # Pandoc 用户指南</description></item><item><title>Shell 脚本相关的问题的解决方法</title><link>https://coderqs.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4/shell%E7%9B%B8%E5%85%B3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4/shell%E7%9B%B8%E5%85%B3/</guid><description>Shell 脚本相关的问题的解决方法 # &amp;ldquo;-bash: !&amp;rdquo;: event not found # 原因 # ! 是 bash 的特殊字符，用于引用之前以!后面字符串开头的最后一个的命令。
!$ 是获取上一条命令的最后一个参数。
注意：在脚本中，所有历史命令都被禁用，因为它们只在交互式 shell 中才有意义
解决方法 # 方法一 # 执行 set +H 临时关闭该功能
方法二 # 将该字符串用单引号括起来，双引号不可以
方法三 # 在 ! 前添加\或后面添加空格，但这种方法有额外的字符混进去，所以如果是输入密码的时候出现的问题，这种方法是不可用的。
参考自 What is “-bash: !”: event notfound&amp;quot;</description></item><item><title>VMware 遇见的问题及解决方法</title><link>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E8%99%9A%E6%8B%9F%E6%9C%BA/vmware/%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E8%99%9A%E6%8B%9F%E6%9C%BA/vmware/%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4/</guid><description>VMware 遇见的问题及解决方法 # 虚拟机繁忙无法关机 # 这种问题出现的原因不明（有看到一些说法是 Windows 10 的某些版本和 VMware 兼容性的问题导致的，但也没找到明确的证据证明，都是凭感觉m(）
解决方法 # 1. 在任务管理器中关闭 vmware workstation vmx.exe 进程
2. 但我在这个地方遇到了问题：就是这个进程根本关不掉！！尝试了各种方法都关不掉！！网上有帖子说 是1903版本与vmware的兼容性问题，但也没有给出解决方案。
3. 通过 Windows 程序与功能将 VMware 修复(没有必要重装，一定不要动原来的虚拟机文件）。修复完成后，虚拟机就可以重新启动了。
参考自： Vmware Workstation虚拟机繁忙导致无法关机</description></item><item><title>Wireshark 常用过滤条件</title><link>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7/wireshark/%E5%B8%B8%E7%94%A8%E8%BF%87%E6%BB%A4%E6%9D%A1%E4%BB%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7/wireshark/%E5%B8%B8%E7%94%A8%E8%BF%87%E6%BB%A4%E6%9D%A1%E4%BB%B6/</guid><description>Wireshark 常用过滤条件 # 根据地址 # 指定 IP # ip 192.168.1.1 指定源 IP # ip.src 192.168.1.1 指定目标 IP # ip.dst 192.168.1.1 指定端口 # 指定 TCP 协议的端口 # tcp.prot 8080 指定 UDP 协议的端口 # udp.prot 8080 指定源端口(以TCP协议为例) # tcp.srcport 8080 指定目标端口(以TCP协议为例) # tcp.dstport 8080 根据时间 # 某一时刻的数据包 # frame.time == &amp;#34;May 27, 2019 15:23:57.932344000&amp;#34; 某一时刻之后的数据包 # frame.time &amp;gt;= &amp;#34;May 27, 2019 15:23:57.</description></item><item><title>Wireshark 遇见的问题的解决办法</title><link>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7/wireshark/%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E5%B7%A5%E5%85%B7/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7/wireshark/%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4/</guid><description>Wireshark 遇见的问题的解决办法 # 选择网卡时卡死无响应 # 在选择网卡后 Wireshark 就会卡死，然后进程未响应，重新打开又重复的卡死无响应的过程。打开任务管理器发现 Wireshark 内存占用迅速上涨，我这里是上涨了 1G 多。
这个跟 TLS 有关。因为我之前弄 webrtc 的时候配置了 https 的解密，并且没有还原配置，然后我浏览器有很久没有重启，导致浏览器的 sslkeylogfile 文件变得很大，而 Wireshark 开始抓包的时候会循环读取 sslkeylogflie 的内容，所以就出现卡死与崩溃的情况。
解决方法 # 方法一 # 重启浏览器，删除 sslkeylogflie 文件。这是临时解决方法，当 sslkeylogflie 文件变大后还是会出现这个问题。
方法二 # 还原 Wireshark 中关于 TLS 的配置。配置路径 编辑-&amp;gt;首选项-&amp;gt;Protocols-&amp;gt;TLS 。
参考资料 # 《Dive into Windbg系列》Wireshark的卡死与崩溃</description></item></channel></rss>