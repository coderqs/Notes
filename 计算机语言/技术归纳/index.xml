<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>清松的笔记本</title><link>https://coderqs.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E6%8A%80%E6%9C%AF%E5%BD%92%E7%BA%B3/</link><description>Recent content on 清松的笔记本</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://coderqs.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E6%8A%80%E6%9C%AF%E5%BD%92%E7%BA%B3/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://coderqs.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E6%8A%80%E6%9C%AF%E5%BD%92%E7%BA%B3/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E8%A7%84%E8%8C%83/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E6%8A%80%E6%9C%AF%E5%BD%92%E7%BA%B3/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E8%A7%84%E8%8C%83/</guid><description>单元测试规范 # 名词解释 # 覆盖率 # 覆盖率是对自动化测试运行期间执行了多少代码产生的度量（100%覆盖意味着每一行代码都至少执行过） 不必追求100%的覆盖率，覆盖率在60%-80%是一个不错的范围，这个主要根据项目的情况来决定。
单元测试原则 # DAMP 和DRY 这是一种平衡，而不是矛盾
DAMP 和 DRY 并不矛盾，而是平衡了代码可维护性的两个不同方面。可维护的代码（易于更改的代码）是这里的最终目标。
DAMP（描述性和有意义的短语）提高了代码的可读性。
要维护代码，首先需要了解代码。要理解它，你必须阅读它。考虑一下你花多少时间阅读代码。这是很多。 DAMP 通过减少阅读和理解代码所需的时间来提高可维护性。
DRY（不要重复自己）促进代码的 正交性。
删除重复确保系统中的每个概念在代码中都有一个单一的权威表示。对单个业务概念的更改会导致对代码的一次更改。DRY 通过将更改（风险）隔离到系统中必须更改的那些部分来提高可维护性。
那么，为什么重复在测试中更容易接受？
测试通常包含固有的重复，因为它们一遍又一遍地测试相同的东西，只是输入值或设置代码略有不同。但是，与生产代码不同的是，这种重复通常仅与单个测试夹具/文件中的场景隔离。因此，重复是最小的和明显的，这意味着它比其他类型的重复给项目带来的风险更小。
此外，删除这种重复会降低测试的可读性。以前在每个测试中重复的细节现在隐藏在一些新方法或类中。为了全面了解测试，您现在必须在精神上将所有这些部分重新组合在一起。
因此，由于测试代码重复通常带来的风险较小，并提高了可读性，因此很容易看出它是如何被认为是可以接受的。
原则上，在生产代码中使用 DRY，在测试代码中使用 DAMP。虽然两者同等重要，但只要稍加智慧，您就可以在对自己有利的情况下平衡。
引用自： 在谈论单元测试时，&amp;ldquo;DAMP not DRY&amp;quot;是什么意思？
单元测试的准则 # 单元测试应该是可靠的，否则不能保证测试结果可信; 单元测试应该是可维护且易于阅读和理解的; 单元测试的每一个测试单元只测试一个用例，这样便于维护; 单元测试应该可以在任何机器上顺序运行，且不会相互影响，如果可以，希望也能不依赖环境因素或全局/外部状态; 单元测试应该自动化; 结合使用单元测试和集成测试; 单元测试应在有组织的测试实践中执行; 单元测试用例的命名方法 # 这里提供以下七种命名方法以供参考
MethodName_StateUnderTest_ExpectedBehavior(方法名_在测试状态_预期行为) # 如果方法名在重构的时候被更改，那么测试用例也应该同样被更改，否则以后会难以被理解。示例：
isAdult_AgeLessThan18_False
withdrawMoney_InvalidAccount_ExceptionThrown
admitStudent_MissingMandatoryFields_FailToAdmit
MethodName_ExpectedBehavior_StateUnderTest(方法名_预期行为_在测试状态) # 与第一种有相同的问题。示例：
isAdult_False_AgeLessThan18</description></item><item><title/><link>https://coderqs.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E6%8A%80%E6%9C%AF%E5%BD%92%E7%BA%B3/%E7%89%88%E6%9C%AC%E5%8F%B7%E7%9A%84%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E6%8A%80%E6%9C%AF%E5%BD%92%E7%BA%B3/%E7%89%88%E6%9C%AC%E5%8F%B7%E7%9A%84%E7%AE%A1%E7%90%86/</guid><description>版本号的管理 # 前言 # 在现代软件开发过程中，相较于“重复造轮子”，开发者往往会利用一些已有的组件（如库、程序、多媒体文件）进行开发。程序开发者根据特定版本的组件来设计自己的软件。这种方式使得代码重复利用，减少了开发的工作量，降低了开发门槛。但是该软件要正确运行，必须安装了指定版本的某些组件。
依赖地狱 # 操作系统中由于软件之间的依赖性不能被满足而引发的问题称为依赖地狱。依赖地狱主要有以下表现：
依赖过多：一个软件包可能依赖于众多的库，因此安装一个软件包的同时要安装几个甚至几十个库包。 多重依赖：指从所需软件包到最底层软件包之间的层级数过多。这会导致依赖性解析过于复杂，并且容易产生依赖冲突和环形依赖。 依赖冲突：即两个软件包无法共存的情况。除两个软件包包含内容直接冲突外，也可能因为其依赖的低层软件包互相冲突。因此，两个看似毫无关联的软件包也可能因为依赖性冲突而无法安装。 依赖循环：即依赖性关系形成一个闭合环路，最终导致：在安装 A 软件包之前，必须要安装 A、B、C、D 软件包，然而这是不可能的。 版本号风格总结 # GUN 风格 # 命名格式 # 主版本号 . 子版本号 [. 修正版本号 build- [编译版本号 ]]
示例：
1.2 1.2.0 1.2.0 build-1234 规范 # 项目初版本时，版本号可以是 0.1 或 0.1.0，可以是 1.0 或 1.0.0，建议主版本号从 0 开始; 当项目在进行了局部修改或 bug 修正时，主版本号和子版本号都不变，修正版本号加 1; 当项目在原有的基础上增加了部分功能时，主版本号不变，子版本号加 1，修正版本号复位为 0，因而可以被忽略掉; 当项目在进行了重大修改或局部修正累积较多，而导致项目整体发生全局变化时，主版本号加 1; 编译版本号一般是编译器在编译过程中自动生成的，我们只定义其格式，并不进行人为控制; Windows 风格 # 命名格式 # 主版本号 .</description></item><item><title/><link>https://coderqs.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E6%8A%80%E6%9C%AF%E5%BD%92%E7%BA%B3/%E7%BC%96%E8%AF%91%E6%9C%BA%E7%8E%AF%E5%A2%83%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E6%8A%80%E6%9C%AF%E5%BD%92%E7%BA%B3/%E7%BC%96%E8%AF%91%E6%9C%BA%E7%8E%AF%E5%A2%83%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95/</guid><description>编译机环境管理方法 # 以用户的方式管理 # 说明 # 创建一个compiler用户 这个用户用于系统默认编译器的的编译 该用户的家目录下存放所有代码 所有添加的其他编译用户都处于compiler中户组（给compiler设置 SGID 可以使其下面的文件夹都默认处于compiler组里） 该用户家目录的所有代码都要给组用户写权限 创建用户，以 NDK 为例，%%android-ndk-r13b-linux-x86_64 对应的用户名 android-ndk-r13 将编译器安装在对应的用户家目录中 将需要的环境变量配置在用户的.bash_prefile中 配置umask，给组与用户同样的权限 演示配置 android-ndk-r13 用户 # # adduser android-ndk-r13 -g compiler # echo &amp;#34;umask 002&amp;#34; &amp;gt;&amp;gt; /home/android-ndk-r13/.bashrc # su - android-ndk-r13 # unzip android-ndk-r13b-linux-x86_64.zip 配置环境变量 # 在~/bash_prefile中添加下面
export NDKROOT=/home/android-ndk-r13/android-ndk-r13b export PATH=$NDKROOT:$PATH INSTALLATION_PATH=/home/output/android-ndk-r13 export prefix=$INSTALLATION_PATH export ANDROID_HOME=~/android-ndk-r13b export TOOLCHAIN=$ANDROID_HOME/android-toolchain export CROSS_SYSROOT=$TOOLCHAIN/sysroot export PATH=$TOOLCHAIN/bin:$PATH export TOOL=arm-linux-androideabi export CC=$TOOLCHAIN/bin/${TOOL}-gcc export CXX=$TOOLCHAIN/bin/${TOOL}-g++ export LINK=${CXX} export LD=$TOOLCHAIN/bin/${TOOL}-ld export AR=$TOOLCHAIN/bin/${TOOL}-ar export RANLIB=$TOOLCHAIN/bin/${TOOL}-ranlib export STRIP=$TOOLCHAIN/bin/${TOOL}-strip export ARCH_FLAGS=&amp;#34;-mthumb&amp;#34; export ARCH_LINK= export CFLAGS=&amp;#34;${ARCH_FLAGS}-fpic -ffunction-sections -funwind-tables -fstack-protector -fno-strict-aliasing -finline-limit=64&amp;#34; export CXXFLAGS=&amp;#34;${CFLAGS}-frtti -fexceptions&amp;#34; export LDFLAGS=&amp;#34;${ARCH_LINK}&amp;#34; 参考资料 # linux下如何实现不同的用户对同一文件都有写权限</description></item></channel></rss>