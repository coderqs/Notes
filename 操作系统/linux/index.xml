<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Linux on 清松的笔记本</title><link>https://coderqs.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/</link><description>Recent content in Linux on 清松的笔记本</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://coderqs.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://coderqs.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/centos7%E6%8C%82%E8%BD%BDwindows%E7%9A%84%E5%85%B1%E4%BA%AB%E7%9B%AE%E5%BD%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/centos7%E6%8C%82%E8%BD%BDwindows%E7%9A%84%E5%85%B1%E4%BA%AB%E7%9B%AE%E5%BD%95/</guid><description>Centos7 挂载 windows 的共享目录 # 步骤 # 1. 在windows上创建一个共享目录 # 设置共享 # 右键需要共享的文件夹，点击“共享”，点击“共享此文件夹”，此时可以设置权限。默认权限是“读取”。
更改权限 # 接着上述步骤，点击“权限”按钮，打开权限对话框，若需要写权限（修改权限），选中Everyone用户组，选中“修改”复选框或者“完全控制”复选框。点击“应用”“确定”。
进入“安全”选项卡，选中Everyone用户组，选中“完全控制”，“应用”“确定”。 更改权限的两步必须同时设置才能生效。
2. 在Centos7上挂载共享目录** 执行下面命令 # mount -t cifs -o username=share,password=share //192.168.31.189/share /share 其中:
username,password 是 windows 登录用户名密码 //192.168.31.189/share 就是windows要的共享文件夹 /share 是希望 Centos7 将共享文件夹要挂载到的地方，可任意定位置 3. 开机启动就挂载文件夹 # 在 /etc/fstab 文件中添加下列代码即可
//192.168.31.189/share /share cifs username=share,password=share 0 0 遇到的问题 # mount -t cifs -o username=share,password=share //192.168.31.189/share /share mount: //192.</description></item><item><title/><link>https://coderqs.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/firewalld%E7%9A%84%E8%A7%84%E5%88%99%E9%85%8D%E7%BD%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/firewalld%E7%9A%84%E8%A7%84%E5%88%99%E9%85%8D%E7%BD%AE/</guid><description>firewalld的规则配置 # 基本功能 # 查看防火墙 # systemctl status firewalld 开启防火墙 # systemctl start firewalld.service 重启防火墙 # firewall-cmd --reload 端口管理 # 查看已开放的端口 # firewall-cmd --zone=public --list-ports 添加端口到白名单 # firewall-cmd --permanent --zone=public --add-port=8484/tcp --zone 作用域 --add-port=8484/tcp 添加端口，格式为：端口/通讯协议 --permanent 永久生效，没有此参数重启后失效 从白名单移除端口 # firewall-cmd --zone=public --remove-port=8484/tcp 服务管理 # 服务只是带有相关名称和描述的端口的简单集合。使用服务比端口更易于管理。
获得可用服务的列表 # firewall-cmd --get-services 查看当前已添加的服务 # firewall-cmd --zone=public --list-services 添加服务 # firewall-cmd --permanent --zone=public --add-service=ssh 自定义服务 # 服务的定义文件通常存放在下面的两个路径中：</description></item><item><title/><link>https://coderqs.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/mailx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/mailx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</guid><description>Mailx 安装与使用 # Mailx 安装 # 安装 # 执行命令
sudo yum install -y mailx 配置 # 在配置文件 /etc/mail.rc 后面追加
set from=username@domain # 对方收到邮件时显示的发件人 set smtp=smtp.domain.com # 指定第三方发送邮件的smtp服务器地址 set smtp-auth-user=username@domain # 第三方发邮件的用户名 set smtp-auth-password=&amp;#34;password&amp;#34; # 用户名对应密码或授权码 set smtp-auth=login # SMTP的认证方式。默认是LOGIN，也可改为CRAM-MD5或PLAIN方式 Mailx的使用 # 可以使用 mail -h 查看帮助
mail: option requires an argument -- h Usage: mail -eiIUdEFntBDNHRVv~ -T FILE -u USER -h hops -r address -s SUBJECT -a FILE -q FILE -f FILE -A ACCOUNT -b USERS -cUSERS -S OPTION users 无正文的邮件 # mail -s &amp;#34;subject&amp;#34; qs@coderqs.</description></item><item><title/><link>https://coderqs.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%8D%87%E7%BA%A7gcc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%8D%87%E7%BA%A7gcc/</guid><description>升级 GCC # 编译 GCC # 下载源码 # 方法一 # 在 gcc官方镜像下载源码的压缩包
wget http://ftp.gnu.org/gnu/gcc/gcc-8.4.0/gcc-8.4.0.tar.gz tar -zxvf gcc-8.4.0.tar.gz 方法二 # 在 github上载，注意这种方式是展开的源码，文件较多较大，下载时间可能更长
git clone https://github.com/gcc-mirror/gcc.git 安装依赖 # yum install -y gmp gmp-devel mpfr mpfr-devel libmpc libmpc-devel 编译安装 # mkdir gcc-8.4.0-build &amp;amp;&amp;amp; cd gcc-8.4.0-build ../gcc-8.4.0/configure --enable-languages=c,c++ --disable-multilib make -j $(nproc) configure 更多的配置选项在 这里查看
注意：编译之前要保证 /tmp 有足够多的磁盘空间！
安装 # make install 添加环境变量 编译默认的安装路径是 /usr/local/bin, 在 /etc/profile 中追加</description></item><item><title/><link>https://coderqs.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E6%9F%A5%E7%9C%8B%E5%BA%93%E7%9A%84%E7%AC%A6%E5%8F%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E6%9F%A5%E7%9C%8B%E5%BA%93%E7%9A%84%E7%AC%A6%E5%8F%B7/</guid><description>查看库的符号 # 查看生成的so是否存在符号未定义的内容 # ldd -r xxx.so 查看 so 中的所有符号 # nm xxx.so 例如下面是 nm 输出的结果中的一段:
U _ZN11CHttpParser20GetCurrentHttpMethodER13http_method_t U _ZN11CHttpParser26ExactResultFromHttpMsgBodyESsRSs U _ZN11CHttpParser5parseESs U _ZN11CHttpParserC1ESs 00000000000134e6 W _ZN5boost10shared_ptrI11CHttpParserE4swapERS2_ 0000000000012e56 W _ZN5boost10shared_ptrI11CHttpParserEC1ERKS2_ 0000000000012e30 W _ZN5boost10shared_ptrI11CHttpParserEC1Ev 0000000000014cda W _ZN5boost10shared_ptrI11CHttpParserEC1IS1_EEPT_ 0000000000012cda W _ZN5boost10shared_ptrI11CHttpParserED1Ev 0000000000013df4 W _ZN5boost10shared_ptrI11CHttpParserEaSERKS2_ 000000000001348b W _ZN5boost14checked_deleteI11CHttpParserEEvPT_ 其输出的结果是以 地址 类型 符号名 的结构显示的，其中一些常见的符号类型如下
nm输出字符 含义 R Read only symbol. 比如在代码中有一个const MAXDATA = 3095; 则MAXDATA就是一个Read only symbol N 这是一个调试符号 D 这是一个已经初始化的变量的符号。比如代码中int i = 1和char *str = &amp;ldquo;Hello&amp;quot;则i和str都是这种类型的符号 T Text段的符号。子程序都是这种符号，比如文件中实现了一个函数function，则function就是这种符号 U 未定义的符号。如果文件中引用了不存在的函数，则这些未定义的函数符号就是这种类型 S 未初始化的符号，比如全局变量int s;则s的符号就是此类型 参考资料 # Linux下使用nm命令排查和解决“undefined referenceto”</description></item><item><title/><link>https://coderqs.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E8%AE%BE%E7%BD%AE%E7%B3%BB%E7%BB%9F%E6%97%B6%E5%8C%BA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://coderqs.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E8%AE%BE%E7%BD%AE%E7%B3%BB%E7%BB%9F%E6%97%B6%E5%8C%BA/</guid><description>方法一：timedatectl # timedatectl 是一个命令行工具，它允许你查看并且修改系统时间和日期。它在所有现代的基于 systemd 的 Linux 系统中都可以使用。
检查时区 # 执行下面命令：
timedatectl 执行后会显示系统的时区。我的机器显示如下：
Local time: Sat 2021-02-19 17:02:22 UTC Universal time: Sat 2021-02-19 17:02:22 UTC RTC time: Sat 2021-02-19 17:02:22 Time zone: UTC (UTC, +0000) System clock synchronized: yes NTP service: active RTC in local TZ: no 可以看到我的机器的时区 Time zone: UTC (UTC, +0000) 是 UTC
修改时区 # 在修改时区时，需要找到想要使用的时区的名字，一般的格式是地区/城市。不知道名字的话可以使用 timedatectl list-timezones 命令来查看，执行后显示如下：
Africa/Abidjan Africa/Accra Africa/Addis_Ababa Africa/Algiers Africa/Asmara .</description></item></channel></rss>